<html>
<head>
    <title>My first three.js app</title>
    <style>
        html, body {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            margin: 0;
        }
        /*body { margin: 0; }*/
        canvas { display: block; }
        .no-pointer-events {
            pointer-events: none;
        }
        .control-disabled {
            color: #888;
            text-decoration: line-through;
        }
        #tooltip {
            position: fixed;
            left: 0;
            top: 0;
            min-width: 100px;
            min-height: 32px;
            text-align: center;
            padding: 5px 12px;
            font-family: monospace;
            color: white;
            background: rgba(0,0,0,0.5);
            display: none;
            opacity: 0;
            border: 1px solid black;
            box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
            transition: opacity 0.25s linear;
            border-radius: 3px;

            background-size: contain;
        }
        .simulationInfo {
            position: fixed;
            height: 40px;
            bottom:0;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugInfo {
            position: fixed;
            height: 40px;
            bottom:40px;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugParticle {
            position: fixed;
            height: 40px;
            top: 0;
            left: 0;
            width:40px;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }

    </style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/RhombicDodecahedronGeometry.js"></script>
<script src="js/Particle.js"></script>
<script src="js/Object.js"></script>
<script src="js/InitialParticles.js"></script>
<div class="simulationInfo"></div>
<div class="debugInfo"></div>
<div class="debugParticle"></div>
    <script type="module">





        // SETUP
        import { GUI } from "./js/dat.gui.module.js";

        var controls;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        var renderer = new THREE.WebGLRenderer();
        var projector, mouse = { x: 0, y: 0 }, INTERSECTED;

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );




        // RESPONSIVE PROJECT
        window.addEventListener( 'resize', function () {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize( width, height);
            camera.aspect = width/height;
            camera.updateProjectionMatrix();

        })




        // MOUSE CONTROL
        controls = new THREE.OrbitControls( camera, renderer.domElement );

        // initialize object to perform world/screen calculations
        projector = new THREE.Projector();

        // when the mouse moves, call the given function
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

        function onDocumentMouseMove( event )
        {
            // the following line would stop any other event handler from firing
            // (such as the mouse's TrackballControls)
            // event.preventDefault();

            // update the mouse variable
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }





        // ON-SCREEN PARAMETRERS (GUI)
        var gui = new GUI();
        var settings = {
            toggleGrid: false,
            toggleAxis: true,
            togglePointLightHelper: false,
            debugMode: false,
            // toggleSpotLightHelper: false,
            color: "#ffff00",
            wireFrame: false,
            extent: false,
            movement: false,
            objectcolor: "#00ff00",
            objectwireFrame: false,
            objectextent: false,
            role: "Inactive",
            initialParticlecolor: "#00ff00",
            initialParticlewireFrame: false,
            initialParticleextent: false,
            createTree: function(){ createTree = true },
            play: function(){ playSimulation() },
            pause: function(){ pauseSimulation() },
            speed: 10,
            nextStep: function(){ nextSimulationStep() },

        };

        var debugGroup = gui.addFolder( 'Debug Tools' );
        debugGroup.add(settings, "toggleGrid").name( "Toggle Grid" ).onChange(function (visible) {
            gridHelper.visible = visible;
        })
        debugGroup.add(settings, "toggleAxis").name( "Toggle Axis" ).onChange(function (visible) {
            axesHelper.visible = visible;
        })
        debugGroup.add(settings, "togglePointLightHelper").name( "Point Light Helper" ).onChange(function (visible) {
            pointLightHelper[0].visible = visible;
            pointLightHelper[1].visible = visible;
            pointLightHelper[2].visible = visible;
        })
        debugGroup.add(settings, "debugMode").name( "Debug" ).onChange(function (value) {
            debugMode = value;
        })
        // debugGroup.add(settings, "toggleSpotLightHelper").name( "Spot Light Helper" ).onChange(function (visible) {
        //     spotLightHelper.visible = visible;
        // })
        // debugGroup.open();


        var particleGroup = gui.addFolder( 'Particle Settings' );
        particleGroup.addColor( settings, "color").name( "Color" ).onChange(function(value){
            coatingParticle.headRhombic.material.color.set(value);
        });
        particleGroup.add( settings, "wireFrame").name( "Wireframe" ).onChange(function(visible){
            coatingParticle.headRhombic.material.wireframe = visible;
        });
        particleGroup.add( settings, "extent").name( "Extent" ).onChange(function(visible){
            coatingParticle.headRhombic.visible = !visible;
            coatingParticle.headPoint.visible = visible;
            coatingParticle.tailRhombic.visible = !visible;
            coatingParticle.tailPoint.visible = visible;
        });
        particleGroup.add( settings, "movement").name( "Movement" ).onChange(function(value){
            if(value){
                speed = 0.1;
            }else{
                speed = 0;
            }

        });
        particleGroup.add( settings, 'role', [ "Inactive", "Retired", "Follower", "Coater", "Leader", "SmallLeader", "Branch", "SmallBranch", "Boundary"] ).name('Role').onChange(function(value){
            switch (value) {
                case "Inactive":
                    coatingParticle.headRhombic.material.color.set(0x6C757D);
                    break;
                case "Retired":
                    coatingParticle.headRhombic.material.color.set(0x121417);
                    break;
                case "Follower":
                    coatingParticle.headRhombic.material.color.set(0x1D3557);
                    break;
                case "Coater":
                    coatingParticle.headRhombic.material.color.set(0x1D3557);
                    break;
                case "Leader":
                    coatingParticle.headRhombic.material.color.set(0xCF2626);
                    break;
                case "SmallLeader":
                    coatingParticle.headRhombic.material.color.set(0xEA6C1B);
                    break;
                case "Branch":
                    coatingParticle.headRhombic.material.color.set(0x583B23);
                    break;
                case "SmallBranch":
                    coatingParticle.headRhombic.material.color.set(0x754E2F);
                    break;
                case "Boundary":
                    coatingParticle.headRhombic.material.color.set(0x000000);
                    break;
                default:
                    break

            }
        });
        particleGroup.open();

        var objectGroup = gui.addFolder( 'Object Settings' );
        objectGroup.addColor( settings, "objectcolor").name( "Color" ).onChange(function(value){
            for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
                layer[Object.keys(layer).length-1][i].head.material.color.set(value);
            }
        });
        objectGroup.add( settings, "objectwireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
                layer[Object.keys(layer).length-1][i].head.material.wireframe = visible;
            }
        });
        objectGroup.add( settings, "objectextent").name( "Extent" ).onChange(function(visible){
            for (let j = 0; j < Object.keys(layer[Object.keys(layer).length-1]).length; j++) {
                layer[Object.keys(layer).length-1][j].headRhombic.visible = !visible;
                layer[Object.keys(layer).length-1][j].headPoint.visible = visible;
            }
        })
        objectGroup.open();

        var initialParticleGroup = gui.addFolder( 'Initial Particles Settings' );
        initialParticleGroup.addColor( settings, "initialParticlecolor").name( "Color" ).onChange(function(value){
            for (let i = 0; i < Object.keys(initialParticles).length; i++) {
                initialParticles[i].head.material.color.set(value);
            }
        });
        initialParticleGroup.add( settings, "initialParticlewireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(initialParticles).length; i++) {
                initialParticles[i].head.material.wireframe = visible;
            }
        });
        // initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
        //     for (let i = 0; i < Object.keys(initialParticles).length; i++) {
        //         initialParticles[i].headRhombic.visible = !visible;
        //         initialParticles[i].headPoint.visible = visible;
        //         initialParticles[i].tailRhombic.visible = !visible;
        //         initialParticles[i].tailPoint.visible = visible;
        //     }
        // });
        initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
            for (let i = 0; i < particleSystem.length; i++) {
                particleSystem[i].headRhombic.visible = !visible;
                particleSystem[i].headPoint.visible = visible;
                particleSystem[i].tailRhombic.visible = !visible;
                particleSystem[i].tailPoint.visible = visible;
            }
        });
        initialParticleGroup.add( settings, "createTree").name( "Create Tree" );
        initialParticleGroup.open();

        var simulationGroup = gui.addFolder( 'Simulation Settings' );
        var alternateButton = [];
        alternateButton.push( simulationGroup.add( settings, 'play' ).name('Play') );
        alternateButton.push( simulationGroup.add( settings, 'pause' ).name('Pause') );

        alternateButton.forEach( function ( control ) {

            control.classList1 = control.domElement.parentElement.parentElement.classList;
            control.classList2 = control.domElement.previousElementSibling.classList;

            control.setDisabled = function () {

                control.classList1.add( 'no-pointer-events' );
                control.classList2.add( 'control-disabled' );

            };

            control.setEnabled = function () {

                control.classList1.remove( 'no-pointer-events' );
                control.classList2.remove( 'control-disabled' );

            };
        })
        alternateButton[1].setDisabled();

        simulationGroup.add( settings, 'speed' ).min(0).max(100).step(1).name('Step Duration (ms)').onChange(function(value){
            stepDuration = value;
        });
        simulationGroup.add( settings, 'nextStep' ).name('Next Step');
        simulationGroup.open();



        // LIGHT
        var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.1 );
        scene.add( ambientLight );

        var pointLight = {};
        pointLight[0] = new THREE.PointLight( 0xFFFFFF, 0.7 );
        pointLight[0].position.set( -20, 25, 25 );
        scene.add( pointLight[0] );

        pointLight[1] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[1].position.set( -25, -25, -25 );
        scene.add( pointLight[1] );

        pointLight[2] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[2].position.set( 33, 0, 0 );
        scene.add( pointLight[2] );


        // var spotLight = new THREE.SpotLight( 0xffffff, 0.6 );
        // spotLight.position.set( 5, 50, 5 );
        // scene.add( spotLight );

        // var spotLightHelper = new THREE.SpotLightHelper( spotLight, "#FF0000" );
        // spotLightHelper.visible = false;
        // scene.add( spotLightHelper );

        var sphereSize = 1;
        var pointLightHelper = {};
        pointLightHelper[0] = new THREE.PointLightHelper( pointLight[0], sphereSize, "#FF0000" );
        pointLightHelper[0].visible = true;
        scene.add( pointLightHelper[0] );

        pointLightHelper[1] = new THREE.PointLightHelper( pointLight[1], sphereSize, "#FF0000" );
        pointLightHelper[1].visible = true;
        scene.add( pointLightHelper[1] );

        pointLightHelper[2] = new THREE.PointLightHelper( pointLight[2], sphereSize, "#FF0000" );
        pointLightHelper[2].visible = true;
        scene.add( pointLightHelper[2] );




        // TEST




        // GRID
        var size = 1000;
        var divisions = 250;
        var gridHelper = new THREE.GridHelper( size, divisions );
        gridHelper.visible = false;
        scene.add( gridHelper );



        // AXIS HELPER
        var axesHelper = new THREE.AxesHelper( 10 );
        axesHelper.material.linewidth = 5;
        scene.add( axesHelper );




        // OBJECT CREATION
        var availablePositions = {};
        availablePositions = generateObject(3, scene);


        // INITIAL PARTICLES CREATION
        renderInitialParticles(scene);





        // COATING PARTICLE
        var coatingParticle = new Particle();
        coatingParticle.head.position.set(availablePositions[5].x, availablePositions[5].y, availablePositions[5].z);
        coatingParticle.tail.position.set(availablePositions[5].x, availablePositions[5].y, availablePositions[5].z);
        console.log(coatingParticle.head.position)

        coatingParticle.convertToRole("Leader");
        scene.add( coatingParticle.head );
        scene.add( coatingParticle.tail );
        scene.add( coatingParticle.headTailConnection );
        scene.add( coatingParticle.targetConnection );
        // coatingParticle.headTailConnection.visible = false;






        camera.position.z = 50;
        scene.background = new THREE.Color( 0xffffff );

        function degrees_to_radians(degrees)
        {
            var pi = Math.PI;
            return degrees * (pi/180);
        }



        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function movementDebug(){
            console.log("  ");
            console.log(coatingParticle.headRhombic.position.x+ " and "+ targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x < targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x > targetPosition.x);
            console.log(coatingParticle.headRhombic.position.y+ " and "+ targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y < targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y > targetPosition.y);
            console.log(coatingParticle.headRhombic.position.z+ " and "+ targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z < targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z > targetPosition.z);
        }

        function getNbrAtPosition(position, list){
            for (let i = 0; i < Object.keys(list).length; i++) {
                if(position.distanceTo(list[i].head.position) === 0) {
                    return i;
                }
            }
            return -1;
        }

        function gatherParticles(){
            particleSystem.push(coatingParticle);
            for (let i = 0; i < Object.keys(initialParticles).length ; i++) {
                particleSystem.push(initialParticles[i]);
            }
        }

        function doesPositionExistInParticleList(position, particleSystem){
            for (let i = 0; i < particleSystem.length; i++) {
                if(position.distanceTo(particleSystem[i].head.position) === 0) {
                    return true;
                }
                if(position.distanceTo(particleSystem[i].tail.position) === 0) {
                    return true;
                }
            }
            return false;
        }

        function getAvExpandPosition(particle){
            var nbrPosition;
            var avPositions = [];
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                if(doesPositionExistInPositionList(nbrPosition, availablePositions)){
                    if(!doesPositionExistInParticleList(nbrPosition, particleSystem)){
                        avPositions.push(nbrPosition);
                    }
                }
            }
            return avPositions;
        }

        // function getNbrParticles(particle){
        //     for (let i = 0; i < 12; i++) {
        //
        //     }
        //
        // }


        function isParticleTargetingMyTail(particle, nbrParticle){

            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(nbrParticle.target[i].distanceTo(particle.tail.position) === 0){
                    return true;
                }

            }
            return false;
        }

        function isParticleTargetingMyHead(particle, nbrParticle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(nbrParticle.target[i].distanceTo(particle.head.position) === 0){
                    return true;
                }

            }
            return false;
        }

        function isNbrOfRole(particle, role){
            var nbrPosition;
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                for (let j = 0; j < particleSystem.length; j++) {
                    if(nbrPosition.distanceTo(particleSystem[j].head.position) === 0){
                        if(particleSystem[j].role === role){
                            return true;
                        }
                    }
                }

            }
            return false;
        }

        function pullParticle(pullingParticle, pulledParticle){
                pulledParticle.tail.position.set(pulledParticle.head.position.x, pulledParticle.head.position.y, pulledParticle.head.position.z);
                pulledParticle.tail.visible = true;
                pulledParticle.head.position.set(pullingParticle.tail.position.x, pullingParticle.tail.position.y, pullingParticle.tail.position.z);
                pulledParticle.headTailConnection.geometry.setFromPoints([pulledParticle.head.position, pulledParticle.tail.position]);
                pulledParticle.headTailConnection.visible = true;
                pulledParticle.isContracted = false;
                pullingParticle.contractParticle();
                pulledParticle.target = [pullingParticle.tail.position];
                updateTargetMarker(pulledParticle);
        }


        // ------------------------  ITERATION STEP   ------------------------ //

        var particleSystem = [];
        gatherParticles();

        function iterationStep(particle){

            if(particle.isContracted){

                switch (particle.role) {
                    case "Inactive":
                        var nbrPosition ;
                        for (let i = 0; i < 12; i++) {
                            nbrPosition = particle.getPosAtFaceI(i);
                            var nbrParticleIdx = getNbrAtPosition(nbrPosition, initialParticles);
                            if(nbrParticleIdx > -1){
                                if(initialParticles[nbrParticleIdx].role === "Follower"){
                                    particle.target = [nbrPosition];
                                    updateTargetMarker(particle);
                                    particle.convertToRole("Follower");
                                    break;
                                }
                            }
                            else if(nbrPosition.distanceTo(coatingParticle.tail.position) === 0){
                                particle.target = [nbrPosition];
                                updateTargetMarker(particle);
                                particle.convertToRole("Follower");
                                break;
                            }
                        }
                        break;
                    case "Leader":
                        // Check if a nbr is Follower
                        if(particle.target.length === 0){
                            if(isNbrOfRole(particle, "Inactive")){
                                break;
                            }
                            var availablePositions = getAvExpandPosition(particle);
                            if(availablePositions.length > 0){
                                particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length-1)]);
                            }else{
                                particle.convertToRole("Retired");
                            }
                            break;
                        }
                        break
                    case "Leaf":
                        // Check if a nbr is Follower
                        var availablePositionsLeaf = getAvExpandPosition(particle);
                        if(availablePositionsLeaf.length > 0){
                            particle.expandParticle(availablePositionsLeaf[getRandomInt(0, availablePositionsLeaf.length-1)]);
                        }
                        break;


                }


            }else{
                switch (particle.role) {
                    case "Leader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallLeader");
                                if(particle.target.length === 0){
                                    particle.convertToRole("Leaf");
                                }else{
                                    particle.convertToRole("Coater");
                                }

                                break;
                            }
                        }
                        break;
                    case "SmallLeader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particle.convertToRole("Leader");
                                break;
                            }
                        }
                        break;
                    case "Follower":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        break;
                    case "Coater":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        break;
                    case "Leaf":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        break;

                }


            }

        }

        // ------------------------  ITERATION STEP END   ------------------------ //




        // DEBUG FUNCTIONS
        function update()
        {
            document.querySelector('.simulationInfo').innerHTML = 'Number of renders: ' + renderer.info.render.calls;
            // find intersections

            // create a Ray with origin at the mouse position
            //   and direction into the scene (camera direction)
            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
            projector.unprojectVector( vector, camera );
            var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

            // create an array containing all objects in the scene with which the ray intersects
            var intersects = ray.intersectObjects( scene.children );

            // INTERSECTED = the object in the scene currently closest to the camera
            //      and intersected by the Ray projected from the mouse position

            // if there is one (or more) intersections
            if ( intersects.length > 0 )
            {
                // if the closest object intersected is not the currently stored intersection object
                if ( intersects[ 0 ].object != INTERSECTED )
                {
                    // restore previous intersection object (if it exists) to its original color
                    if ( INTERSECTED )
                        INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                    // store reference to closest object as current intersection object
                    INTERSECTED = intersects[ 0 ].object;
                    // store color of closest object (for later restoration)
                    INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                    document.querySelector('.simulationInfo').innerHTML = 'Number of renders: ' + renderer.info.render.calls;
                    // set a new color for closest object
                    INTERSECTED.material.color.setHex( 0xffff00 );
                }
            }
            else // there are no intersections
            {
                // restore previous intersection object (if it exists) to its original color
                if ( INTERSECTED )
                    INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                // remove previous intersection object reference
                //     by setting current intersection object to "nothing"
                INTERSECTED = null;
            }


            if ( keyboard.pressed("z") )
            {
                // do something
            }

            controls.update();
            stats.update();
        }

        function updateTargetMarker(particle){
            if(!(particle.target.length > 0)){
                console.log("Target not set properly")
            }
            particle.targetConnection.geometry.setFromPoints([particle.head.position, particle.target[0]]);
            particle.targetConnection.computeLineDistances();
        }

        var particleSystemIdx = 0;
        var activations = 0;
        function nextSimulationStep(){
            iterationStep(particleSystem[particleSystemIdx]);

            particleSystemIdx++;
            activations++;
            particleSystemIdx = particleSystemIdx % (particleSystem.length);
            document.querySelector('.simulationInfo').innerHTML = 'Number of activations: ' + activations + ' Round : '+ Math.ceil(activations/particleSystem.length);
        }

        function playSimulation(){
            console.log("Play Simulation");
            alternateButton[1].setEnabled();
            alternateButton[0].setDisabled();
            simulation = true;
        }

        function pauseSimulation(){
            console.log("Pause simulation");
            alternateButton[0].setEnabled();
            alternateButton[1].setDisabled();
            simulation = false;
        }


        var speed = 0.0;
        var createTree = false;
        var simulation = false;
        var debugMode = false;
        var stepDuration = 2000;
        var animate = function () {
            requestAnimationFrame( animate );
            if(simulation){
                // setTimeout(nextSimulationStep(), stepDuration);
                nextSimulationStep();
                console.log(renderer.info.render.calls);

            }

            // adjustMovement(coatingParticle, targetPosition);
            // if(hasObjectReachedTarget(coatingParticle.headRhombic, targetPosition)){
            //     calculateParticleTestNewMovementPosition();
            // }

            renderer.render( scene, camera );
            if(debugMode){
                update();
            }
        };

        animate();
    </script>

</body>
</html>