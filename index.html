<html>
<head>
    <title>My first three.js app</title>
    <style>
        html, body {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            margin: 0;
        }
        /*body { margin: 0; }*/
        canvas { display: block; }
        .no-pointer-events {
            pointer-events: none;
        }
        .control-disabled {
            color: #888;
            text-decoration: line-through;
        }
        #tooltip {
            position: fixed;
            left: 0;
            top: 0;
            min-width: 100px;
            min-height: 32px;
            text-align: center;
            padding: 5px 12px;
            font-family: monospace;
            color: white;
            background: rgba(0,0,0,0.5);
            display: none;
            opacity: 0;
            border: 1px solid black;
            box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
            transition: opacity 0.25s linear;
            border-radius: 3px;

            background-size: contain;
        }
        .simulationInfo {
            position: fixed;
            height: 40px;
            bottom:0;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugInfo {
            position: fixed;
            height: 40px;
            bottom:40px;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugParticle {
            position: fixed;
            height: 240px;
            top: 0;
            left: 0;
            width: 180px;
            margin-left: 5px;
            margin-top: 5px;
            opacity: 1;
            z-index: 1;
            color: #000;
            font-size: 15px;
            text-align: left;
        }

    </style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/RhombicDodecahedronGeometry.js"></script>
<script src="js/Particle.js"></script>
<script src="js/Object.js"></script>
<script src="js/InitialParticles.js"></script>
<div class="simulationInfo"></div>
<div class="debugInfo"></div>
<div class="debugParticle"></div>
    <script type="module">





        // SETUP
        import { GUI } from "./js/dat.gui.module.js";

        var controls;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        var renderer = new THREE.WebGLRenderer();
        var raycaster, mouse = { x: 0, y: 0 }, INTERSECTED;

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );




        // RESPONSIVE PROJECT
        window.addEventListener( 'resize', function () {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize( width, height);
            camera.aspect = width/height;
            camera.updateProjectionMatrix();

        })




        // MOUSE CONTROL
        controls = new THREE.OrbitControls( camera, renderer.domElement );

        // initialize object to perform world/screen calculations
        raycaster = new THREE.Raycaster();

        // when the mouse moves, call the given function
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );

        function onDocumentMouseMove( event )
        {
            // the following line would stop any other event handler from firing
            // (such as the mouse's TrackballControls)
            // event.preventDefault();

            // update the mouse variable
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }





        // ON-SCREEN PARAMETRERS (GUI)
        var gui = new GUI();
        var settings = {
            toggleGrid: false,
            toggleAxis: true,
            togglePointLightHelper: false,
            debugMode: false,
            // toggleSpotLightHelper: false,
            color: "#ffff00",
            wireFrame: false,
            extent: false,
            movement: false,
            objectcolor: "#00ff00",
            objectwireFrame: false,
            objectextent: false,
            role: "Inactive",
            initialParticlecolor: "#00ff00",
            initialParticlewireFrame: false,
            initialParticleextent: false,
            createTree: function(){ createTree = true },
            play: function(){ playSimulation() },
            pause: function(){ pauseSimulation() },
            speed: 10,
            nextStep: function(){ nextSimulationStep() },
            random: false,

        };

        var debugGroup = gui.addFolder( 'Debug Tools' );
        debugGroup.add(settings, "toggleGrid").name( "Toggle Grid" ).onChange(function (visible) {
            gridHelper.visible = visible;
        })
        debugGroup.add(settings, "toggleAxis").name( "Toggle Axis" ).onChange(function (visible) {
            axesHelper.visible = visible;
        })
        debugGroup.add(settings, "togglePointLightHelper").name( "Point Light Helper" ).onChange(function (visible) {
            pointLightHelper[0].visible = visible;
            pointLightHelper[1].visible = visible;
            pointLightHelper[2].visible = visible;
        })
        debugGroup.add(settings, "debugMode").name( "Debug" ).onChange(function (value) {
            debugMode = value;
        })
        // debugGroup.add(settings, "toggleSpotLightHelper").name( "Spot Light Helper" ).onChange(function (visible) {
        //     spotLightHelper.visible = visible;
        // })
        // debugGroup.open();


        var particleGroup = gui.addFolder( 'Particle Settings' );
        particleGroup.addColor( settings, "color").name( "Color" ).onChange(function(value){
            coatingParticle.headRhombic.material.color.set(value);
        });
        particleGroup.add( settings, "wireFrame").name( "Wireframe" ).onChange(function(visible){
            coatingParticle.headRhombic.material.wireframe = visible;
        });
        particleGroup.add( settings, "extent").name( "Extent" ).onChange(function(visible){
            coatingParticle.headRhombic.visible = !visible;
            coatingParticle.headPoint.visible = visible;
            coatingParticle.tailRhombic.visible = !visible;
            coatingParticle.tailPoint.visible = visible;
        });
        particleGroup.add( settings, "movement").name( "Movement" ).onChange(function(value){
            if(value){
                speed = 0.1;
            }else{
                speed = 0;
            }

        });
        particleGroup.add( settings, 'role', [ "Inactive", "Retired", "Follower", "Coater", "Leader", "SmallLeader", "Branch", "SmallBranch", "Boundary"] ).name('Role').onChange(function(value){
            switch (value) {
                case "Inactive":
                    coatingParticle.headRhombic.material.color.set(0x6C757D);
                    break;
                case "Retired":
                    coatingParticle.headRhombic.material.color.set(0x121417);
                    break;
                case "Follower":
                    coatingParticle.headRhombic.material.color.set(0x1D3557);
                    break;
                case "Coater":
                    coatingParticle.headRhombic.material.color.set(0x1D3557);
                    break;
                case "Leader":
                    coatingParticle.headRhombic.material.color.set(0xCF2626);
                    break;
                case "SmallLeader":
                    coatingParticle.headRhombic.material.color.set(0xEA6C1B);
                    break;
                case "Branch":
                    coatingParticle.headRhombic.material.color.set(0x583B23);
                    break;
                case "SmallBranch":
                    coatingParticle.headRhombic.material.color.set(0x754E2F);
                    break;
                case "Boundary":
                    coatingParticle.headRhombic.material.color.set(0x000000);
                    break;
                default:
                    break

            }
        });
        particleGroup.open();

        var objectGroup = gui.addFolder( 'Object Settings' );
        objectGroup.addColor( settings, "objectcolor").name( "Color" ).onChange(function(value){
            for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
                layer[Object.keys(layer).length-1][i].head[0].material.color.set(value);
            }
        });
        objectGroup.add( settings, "objectwireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
                layer[Object.keys(layer).length-1][i].head.material.wireframe = visible;
            }
        });
        objectGroup.add( settings, "objectextent").name( "Extent" ).onChange(function(visible){
            for (let j = 0; j < Object.keys(layer[Object.keys(layer).length-1]).length; j++) {
                layer[Object.keys(layer).length-1][j].headRhombic.visible = !visible;
                layer[Object.keys(layer).length-1][j].headPoint.visible = visible;
            }
        })
        objectGroup.open();

        var initialParticleGroup = gui.addFolder( 'Initial Particles Settings' );
        initialParticleGroup.addColor( settings, "initialParticlecolor").name( "Color" ).onChange(function(value){
            for (let i = 0; i < Object.keys(initialParticles).length; i++) {
                initialParticles[i].head.material.color.set(value);
            }
        });
        initialParticleGroup.add( settings, "initialParticlewireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(initialParticles).length; i++) {
                initialParticles[i].head.material.wireframe = visible;
            }
        });
        // initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
        //     for (let i = 0; i < Object.keys(initialParticles).length; i++) {
        //         initialParticles[i].headRhombic.visible = !visible;
        //         initialParticles[i].headPoint.visible = visible;
        //         initialParticles[i].tailRhombic.visible = !visible;
        //         initialParticles[i].tailPoint.visible = visible;
        //     }
        // });
        initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
            for (let i = 0; i < particleSystem.length; i++) {
                particleSystem[i].headRhombic.visible = !visible;
                particleSystem[i].headPoint.visible = visible;
                particleSystem[i].tailRhombic.visible = !visible;
                particleSystem[i].tailPoint.visible = visible;
            }
        });
        initialParticleGroup.add( settings, "createTree").name( "Create Tree" );
        initialParticleGroup.open();

        var simulationGroup = gui.addFolder( 'Simulation Settings' );
        var alternateButton = [];
        alternateButton.push( simulationGroup.add( settings, 'play' ).name('Play') );
        alternateButton.push( simulationGroup.add( settings, 'pause' ).name('Pause') );

        alternateButton.forEach( function ( control ) {

            control.classList1 = control.domElement.parentElement.parentElement.classList;
            control.classList2 = control.domElement.previousElementSibling.classList;

            control.setDisabled = function () {

                control.classList1.add( 'no-pointer-events' );
                control.classList2.add( 'control-disabled' );

            };

            control.setEnabled = function () {

                control.classList1.remove( 'no-pointer-events' );
                control.classList2.remove( 'control-disabled' );

            };
        })
        alternateButton[1].setDisabled();

        simulationGroup.add( settings, 'speed' ).min(0).max(100).step(1).name('Step Duration (ms)').onChange(function(value){
            stepDuration = value;
        });
        simulationGroup.add( settings, 'nextStep' ).name('Next Step');
        simulationGroup.add( settings, 'random' ).name('Use Random Activations').onChange(function(value){
            randomParticleSelection = value;
        });
        simulationGroup.open();



        // LIGHT
        var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.1 );
        scene.add( ambientLight );

        var pointLight = {};
        pointLight[0] = new THREE.PointLight( 0xFFFFFF, 0.7 );
        pointLight[0].position.set( -20, 25, 25 );
        scene.add( pointLight[0] );

        pointLight[1] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[1].position.set( -25, -25, -25 );
        scene.add( pointLight[1] );

        pointLight[2] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[2].position.set( 33, 0, 0 );
        scene.add( pointLight[2] );


        // var spotLight = new THREE.SpotLight( 0xffffff, 0.6 );
        // spotLight.position.set( 5, 50, 5 );
        // scene.add( spotLight );

        // var spotLightHelper = new THREE.SpotLightHelper( spotLight, "#FF0000" );
        // spotLightHelper.visible = false;
        // scene.add( spotLightHelper );

        var sphereSize = 1;
        var pointLightHelper = {};
        pointLightHelper[0] = new THREE.PointLightHelper( pointLight[0], sphereSize, "#FF0000" );
        pointLightHelper[0].visible = true;
        scene.add( pointLightHelper[0] );

        pointLightHelper[1] = new THREE.PointLightHelper( pointLight[1], sphereSize, "#FF0000" );
        pointLightHelper[1].visible = true;
        scene.add( pointLightHelper[1] );

        pointLightHelper[2] = new THREE.PointLightHelper( pointLight[2], sphereSize, "#FF0000" );
        pointLightHelper[2].visible = true;
        scene.add( pointLightHelper[2] );




        // TEST




        // GRID
        var size = 1000;
        var divisions = 250;
        var gridHelper = new THREE.GridHelper( size, divisions );
        gridHelper.visible = false;
        // scene.add( gridHelper );



        // AXIS HELPER
        var axesHelper = new THREE.AxesHelper( 10 );
        axesHelper.material.linewidth = 5;
        scene.add( axesHelper );




        // OBJECT CREATION
        var availableMovementPositions = {};
        availableMovementPositions = generateObject(2, scene);


        // INITIAL PARTICLES CREATION
        renderInitialParticles(scene);





        // COATING PARTICLE
        var coatingParticle = new Particle();
        coatingParticle.head.position.set(availableMovementPositions[5].x, availableMovementPositions[5].y, availableMovementPositions[5].z);
        coatingParticle.tail.position.set(availableMovementPositions[5].x, availableMovementPositions[5].y, availableMovementPositions[5].z);

        coatingParticle.convertToRole("Leader");
        scene.add( coatingParticle.head );
        scene.add( coatingParticle.tail );
        scene.add( coatingParticle.headTailConnection );
        scene.add( coatingParticle.target0 );
        // coatingParticle.headTailConnection.visible = false;






        camera.position.z = 50;
        scene.background = new THREE.Color( 0xffffff );

        function degrees_to_radians(degrees)
        {
            var pi = Math.PI;
            return degrees * (pi/180);
        }



        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function movementDebug(){
            console.log("  ");
            console.log(coatingParticle.headRhombic.position.x+ " and "+ targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x < targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x > targetPosition.x);
            console.log(coatingParticle.headRhombic.position.y+ " and "+ targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y < targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y > targetPosition.y);
            console.log(coatingParticle.headRhombic.position.z+ " and "+ targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z < targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z > targetPosition.z);
        }

        function getNbrIdxAtPosition(position){
            for (let i = 0; i < particleSystem.length; i++) {
                if(position.distanceTo(particleSystem[i].head.position) === 0) {
                    return i;
                }
            }
            return -1;
        }

        function gatherParticles(){
            particleSystem.push(coatingParticle);
            for (let i = 0; i < Object.keys(initialParticles).length ; i++) {
                particleSystem.push(initialParticles[i]);
            }
        }

        function doesPositionExistInParticleList(position){
            for (let i = 0; i < particleSystem.length; i++) {
                if(position.distanceTo(particleSystem[i].head.position) === 0) {
                    return true;
                }
                if(position.distanceTo(particleSystem[i].tail.position) === 0) {
                    return true;
                }
            }
            return false;
        }

        function doesPositionExistInList(position, list){
            for (let i = 0; i < list.length; i++) {
                if(position.distanceTo(list[i].head.position) === 0) {
                    return true;
                }
                if(position.distanceTo(list[i].tail.position) === 0) {
                    return true;
                }
            }
            return false;
        }

        function getAvExpandPosition(particle){
            var nbrPosition;
            var avPositions = [];
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                if(doesPositionExistInPositionList(nbrPosition, availableMovementPositions)){
                    if(!doesPositionExistInParticleList(nbrPosition)){
                        avPositions.push(nbrPosition);
                    }
                }
            }
            return avPositions;
        }

        // function getNbrParticles(particle){
        //     for (let i = 0; i < 12; i++) {
        //
        //     }
        //
        // }


        function isParticleTargetingMyTail(particle, nbrParticle){

            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(nbrParticle.target[i].distanceTo(particle.tail.position) === 0){
                    return true;
                }
            }
            return false;
        }

        function isParticleTargetingMyHead(particle, nbrParticle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(nbrParticle.target[i].distanceTo(particle.head.position) === 0){
                    return true;
                }

            }
            return false;
        }

        function isNbrOfRole(particle, role){
            var nbrPosition;
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                for (let j = 0; j < particleSystem.length; j++) {
                    if(nbrPosition.distanceTo(particleSystem[j].head.position) === 0){
                        if(particleSystem[j].role === role){
                            return true;
                        }
                    }
                }

            }
            return false;
        }

        function isTargetOfRole(particle, role){
            for (let j = 0; j < particleSystem.length; j++) {
                for (let i = 0; i < particle.target.length; i++) {
                    if(particle.target[i].distanceTo(particleSystem[j].head.position) === 0){
                        if(particleSystem[j].role === role){
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        // Branch helper functions

        function canCoaterBranch(coater){
            let targetIsCoater = false;
            let targetedByCoater = false;
            for (let j = 0; j < particleSystem.length; j++) {

                for (let i = 0; i < coater.target.length; i++) {
                    if(coater.target[i].distanceTo(particleSystem[j].tail.position) === 0){
                        if(particleSystem[j].role === "Coater"){
                            targetIsCoater = true;
                        }
                    }
                }



                for (let i = 0; i < particleSystem[j].target.length; i++) {
                    if( particleSystem[j].target[i] == null){
                        console.log(particleSystem[j]);
                    }
                    if(particleSystem[j].target[i].distanceTo(coater.tail.position) === 0){
                        if(particleSystem[j].role === "Coater"){
                            targetedByCoater = true;
                        }
                    }
                }

            }
            return (targetIsCoater && targetedByCoater);
        }

        function passSecondPointer(branch, smallBranch){
            smallBranch.target.push(findTargetFace(smallBranch, branch.target[0]))
        }


        function swapBranchTarget(branch){
            let tempTarget0 = branch.target[0];
            let tempTarget1 = branch.target[1];
            branch.target = [];
            branch.target.push(tempTarget1);
            branch.target.push(tempTarget0);
        }

        function updateBranchTargets(branch, pullingParticle){
            branch.target[0] = findTargetFace(branch, pullingParticle.tail.position);
            branch.target0.geometry.setFromPoints(getTargetMarkerPoints(branch.head.position, branch.target[0]));
            branch.target1.geometry.setFromPoints(getTargetMarkerPoints(branch.tail.position, branch.target[1]));

        }

        function updateSmallBranchTargets(smallBranch, branch){
            smallBranch.target[0] = findTargetFace(smallBranch, branch.head.position);
            smallBranch.target0.geometry.setFromPoints(getTargetMarkerPoints(smallBranch.head.position, branch.target[0]));
            smallBranch.target.push(findTargetFace(smallBranch, branch.target[1]));
            smallBranch.target1.geometry.setFromPoints(getTargetMarkerPoints(smallBranch.head.position, branch.target[1]));
        }

        function addBranchTargetVisualMarker(particle){
            scene.add(particle.target1);
            if(particle.role === "Leaf"){
                particle.target1.geometry.setFromPoints(getTargetMarkerPoints(particle.tail.position, particle.target[0]));
            }else{
                particle.target0.geometry.setFromPoints(getTargetMarkerPoints(particle.tail.position, particle.target[1]));
            }
        }


        function getTargetMarkerPoints(origin, target){
            return [origin, findMidPoint(origin,target)];
        }

        function findMidPoint(vertex1, vertex2){
            return new THREE.Vector3((vertex1.x + vertex2.x) / 2, (vertex1.y + vertex2.y) / 2, (vertex1.z + vertex2.z) / 2);
        }



        function isTargetRetired(particle){
            for (let j = 0; j < particleSystem.length; j++) {
                for (let i = 0; i < particle.target.length; i++) {
                    if(particle.target[i].distanceTo(particleSystem[j].tail.position) === 0){
                        if(particleSystem[j].role === "Retired"){
                            particle.convertToRole("Coater");
                            let target;
                            if(i === 0){
                                target = particle.target[1];
                                particle.target = [];
                                particle.target.push(target);
                            }else{
                                target = particle.target[0];
                                particle.target = [];
                                particle.target.push(target);
                            }
                            return;
                        }
                    }
                }
            }
        }


        function contractParticle(particle){
            particle.tail.position.set(particle.head.position.x, particle.head.position.y, particle.head.position.z);
            particle.tail.visible = false;
            particle.headTailConnection.visible = false;
            particle.isContracted = true;
        }

        function pullParticle(pullingParticle, pulledParticle){
            if(pullingParticle.tail.position.distanceTo(pulledParticle.head.position) > 4){
                console.log("Particle pulling :");
                console.log( pullingParticle );
                console.log("Particle being pulled :" );
                console.log( pulledParticle );
                pauseSimulation();
                return;
            }
            pulledParticle.tail.visible = true;
            pulledParticle.head.position.set(pullingParticle.tail.position.x, pullingParticle.tail.position.y, pullingParticle.tail.position.z);
            pulledParticle.headTailConnection.geometry.setFromPoints([pulledParticle.head.position, pulledParticle.tail.position]);
            pulledParticle.headTailConnection.visible = true;
            pulledParticle.isContracted = false;
            contractParticle(pullingParticle);
            if(pullingParticle.role === "Branch"){
                updateSmallBranchTargets(pulledParticle, pullingParticle);
            }else if(pulledParticle.role === "Branch"){
                if(pulledParticle.target[1].distanceTo(pulledParticle.head.position) === 0){
                    swapBranchTarget(pulledParticle);
                }
                updateBranchTargets(pulledParticle, pullingParticle);
                // updateMultipleTargets(pulledParticle, pullingParticle);
                // updateMultipleTargetMarkers(pulledParticle);

            }else{
                updateSingleTarget(pulledParticle, pullingParticle.tail.position);
                updateTargetMarker(pulledParticle);
            }
        }

        function findTargetFace(particle, target){
            var nbrFacePos;
            for (let i = 0; i < 12; i++) {
                nbrFacePos = particle.getPosAtFaceI(i);
                if(nbrFacePos.distanceTo(target) === 0){
                    return nbrFacePos;
                }
            }
            console.log("Target is not within vacinity of particle")
        }

        var interestPoint = new THREE.Vector3(-4,14, 10);
        function updateSingleTarget(particle, target){
            particle.target = [];
            particle.target.push(findTargetFace(particle, target));
        }

        function checkIfFollowerCanContract(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(isParticleTargetingMyTail(particle, particleSystem[i])){
                    return false;
                }
            }
            return true;
        }

        function checkForTermination(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(particleSystem[i].isContracted){
                    if(particle.target[0].distanceTo(particleSystem[i].head.position) === 0){
                        if(particleSystem[i].role === "Retired"){
                           return true;
                        }
                    }
                }
            }
            return false;
        }



        // ------------------------  ITERATION STEP   ------------------------ //

        var particleSystem = [];
        var expansionPhase = true;
        gatherParticles();

        function iterationStep(particle){

            if(particle.isContracted){

                switch (particle.role) {
                    case "Inactive":
                        var nbrPosition ;
                        for (let i = 0; i < 12; i++) {
                            nbrPosition = particle.getPosAtFaceI(i);
                            var nbrParticleIdx = getNbrIdxAtPosition(nbrPosition, particleSystem);
                            if(nbrParticleIdx > -1){
                                if(particleSystem[nbrParticleIdx].role === "Follower"){
                                    // particle.target = [nbrPosition];
                                    updateSingleTarget(particle, nbrPosition);
                                    updateTargetMarker(particle);
                                    particle.convertToRole("Follower");
                                    break;
                                }
                                else if(particleSystem[nbrParticleIdx].role === "Leader"){
                                    // particle.target = [nbrPosition];
                                    if(particleSystem[nbrParticleIdx].tail.position.distanceTo(nbrPosition) === 0){
                                        updateSingleTarget(particle, nbrPosition);
                                        updateTargetMarker(particle);
                                        particle.convertToRole("Follower");
                                        break;
                                    }

                                }
                            }
                        }
                        break;
                    case "Leader":
                        if(expansionPhase){
                            if(particle.target.length === 0){
                                if(isNbrOfRole(particle, "Inactive")){
                                    break;
                                }
                                let availablePositions = getAvExpandPosition(particle);
                                if(availablePositions.length > 0){
                                    particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length-1)]);
                                }
                                break;
                            }
                            if(checkForTermination(particle)){
                                particle.convertToRole("Retired");
                                pauseSimulation();
                                console.log("Layer Complete");
                            }
                            if(!isAParticleTargetingMe(particle)){
                                expansionPhase = true;
                            }
                        }else{
                            particle.convertToRole("Retired");
                        }
                        // Check if a nbr is Follower

                        break
                    case "Leaf":
                        // Check if a nbr is Follower
                        let availablePositions = getAvExpandPosition(particle);
                        if(availablePositions.length > 0){
                            particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length-1)]);
                        }else{
                            particle.convertToRole("Retired");
                            scene.remove(particle.tail);
                            scene.remove(particle.target0);
                            scene.remove(particle.target1);
                        }
                        break;
                    case "Coater":
                        if(isTargetOfRole(particle, "Retired")){
                            particle.convertToRole("Leaf");
                            scene.remove(particle.target0);
                        }
                        if(canCoaterBranch(particle)){
                            let availablePositions = getAvExpandPosition(particle);
                            let target = particle.target;
                            if(availablePositions.length > 0) {
                                particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length - 1)]);
                                particle.convertToRole("Leaf");
                                particle.target = target;
                                addBranchTargetVisualMarker(particle);
                            }
                        }
                        break;
                    case "Branch":
                        isTargetRetired(particle);
                        break;
                    case "Follower":
                        if(isTargetOfRole(particle, "Retired")){
                            retireLayer();
                            availableMovementPositions = findNewAvPositions();
                            particle.convertToRole("Leader");
                            particle.target = [];
                            console.log("New Layer start");
                            console.log(particleSystem);
                            console.log(availableMovementPositions);
                        }
                        break;
                }


            }else{
                switch (particle.role) {
                    case "Leader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallLeader");
                                if(particle.target.length === 0){
                                    particle.convertToRole("Leaf");
                                }else{
                                    particle.convertToRole("Coater");
                                }
                                break;
                            }
                        }
                        break;
                    case "SmallLeader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particle.convertToRole("Leader");
                                break;
                            }
                        }
                        if(checkIfFollowerCanContract(particle)){
                            contractParticle(particle);
                            particle.convertToRole("Leader");
                        }
                        break;
                    case "Coater":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        break;
                    case "SmallBranch":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particle.convertToRole("Branch");
                                break;
                            }
                        }
                        break;
                    case "Branch":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallBranch");
                                particle.convertToRole("Coater");
                                particle.target.pop();
                                scene.remove(particle.target1);
                                // removeExtraTarget(particle, particleSystem[j]);
                                // removeBranchTargetVisualMarker(particle);
                                break;
                            }
                        }
                        break;
                    case "Follower":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        if(checkIfFollowerCanContract(particle)){
                            contractParticle(particle);
                        }
                        break;
                    case "Leaf":
                        if(expansionPhase){
                            if(particle.target.length > 0){
                                for (let j = 0; j < particleSystem.length; j++) {
                                    if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                        pullParticle(particle, particleSystem[j]);
                                        particleSystem[j].convertToRole("SmallBranch");
                                        passSecondPointer(particle, particleSystem[j]);
                                        particle.target = [];
                                        break;
                                    }
                                }
                            }else{
                                for (let j = 0; j < particleSystem.length; j++) {
                                    if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                        pullParticle(particle, particleSystem[j]);
                                        break;
                                    }
                                }
                            }
                        }else{
                            reverseContractParticle(particle);
                        }
                        break;
                }
            }

        }

        // ------------------------  ITERATION STEP END   ------------------------ //


        // Retraction phase
        function isAParticleTargetingMe(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(isParticleTargetingMyHead(particle, particleSystem[i]) || isParticleTargetingMyTail(particle, particleSystem[i])){
                    return false;
                }else{
                    return true;
                }
            }
        }

        function reversePullParticle(pullingParticle, pulledParticle){
            if(pullingParticle.head.position.distanceTo(pulledParticle.tail.position) > 4){
                console.log("Dangerous Reverse Pull")
                console.log("Particle pulling :");
                console.log( pullingParticle );
                console.log("Particle being pulled :" );
                console.log( pulledParticle );
                pauseSimulation();
                return;
            }

            pulledParticle.tail.visible = true;
            pulledParticle.tail.position.set(pullingParticle.head.position.x, pullingParticle.head.position.y, pullingParticle.head.position.z);
            pulledParticle.headTailConnection.geometry.setFromPoints([pulledParticle.head.position, pulledParticle.tail.position]);
            pulledParticle.headTailConnection.visible = true;
            pulledParticle.isContracted = false;
            reverseContractParticle(pullingParticle);
            if(pullingParticle.role === "Branch"){
                updateSmallBranchTargets(pulledParticle, pullingParticle);
            }else if(pulledParticle.role === "Branch"){
                if(pulledParticle.target[1].distanceTo(pulledParticle.head.position) === 0){
                    swapBranchTarget(pulledParticle);
                }
                updateBranchTargets(pulledParticle, pullingParticle);
                // updateMultipleTargets(pulledParticle, pullingParticle);
                // updateMultipleTargetMarkers(pulledParticle);

            }else{
                updateSingleTarget(pulledParticle, pullingParticle.tail.position);
                updateTargetMarker(pulledParticle);
            }
        }

        function reverseContractParticle(particle){
            particle.head.position.set(particle.tail.position.x, particle.tail.position.y, particle.tail.position.z);
            particle.tail.visible = false;
            particle.headTailConnection.visible = false;
            particle.isContracted = true;
        }

        // Trigger Next Layer
        var layerSystem = [];
        function retireLayer(){
            let newParticleSystem = [];
            for (let i = 0; i < particleSystem.length; i++) {
                if(particleSystem[i].role === "Retired"){
                    layerSystem.push(particleSystem[i]);
                }else{
                    newParticleSystem.push(particleSystem[i]);
                }
            }
            particleSystem = [];
            for (let i = 0; i < newParticleSystem.length; i++) {
                console.log("particle added");
                particleSystem.push(newParticleSystem[i]);
            }
        }


        function findNewAvPositions(){
            var layerIdx = Object.keys(layer).length-1;
            var avPosition = {};
            var arrayIdx = 0;
            // For each particle in Layer[layerIdx]
            for (let j = 0; j < layerSystem.length; j++) {
                for (let i = 0; i < 12; i++) {
                    // Get position adjacent to face j
                    var particleNbrPosition = layerSystem[j].getPosAtFaceI(i);
                    if(!doesPositionExistInLayer(particleNbrPosition, layer[layerIdx])){
                        if(!doesPositionExistInList(particleNbrPosition, layerSystem)){
                            if(!doesPositionExistInPositionList(particleNbrPosition, avPosition)) {
                                avPosition[arrayIdx] = new THREE.Vector3(particleNbrPosition.x, particleNbrPosition.y, particleNbrPosition.z)
                                arrayIdx++;
                            }
                        }
                    }
                }
            }
            return avPosition;
        }



        // 3D Coordinate System Improvement

        var coordinateSystem = new Array(new Array(new Array()));
        var negativeCoordinateOffset = 25;
        var useImprovedMethod = true;

        function findParticleInCoordSys(coordinate){
            if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] != null){
                return coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset];
            }
        }

        function addParticleToCoordSys(particle, coordinate){
            if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] != null){
                coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
            }else{
                console.log("Can't add particle to system, coordinate is already occupied");
            }
        }

        function contractParticleInCoordSys(particle){
            if(coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] != null){
                if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset]){
                    coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
                    coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] = particle;
                }else{
                    console.log("Cannot update target coordinate, target coordinate is already occupied");
                }
            }else{
                console.log("Particle not found in the coordinate system");
            }
        }

        function expandParticleInCoordSys(particle, target){
            if(coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] != null){
                if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset]){
                    coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
                    coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] = particle;
                }else{
                    console.log("Cannot update target coordinate, target coordinate is already occupied");
                }
            }else{
                console.log("Particle not found in the coordinate system");
            }
        }




        // DEBUG FUNCTIONS
        function update()
        {
            document.querySelector('.simulationInfo').innerHTML = 'Number of renders: ' + renderer.info.render.calls;

            // controls.update();
            // stats.update();
        }

        function findParticleWithObjectId(objectID){
            for (let i = 0; i < particleSystem.length; i++) {
                if((particleSystem[i].head.id === objectID) || (particleSystem[i].tail.id === objectID)){
                    return particleSystem[i];
                }
            }
        }

        function drawFocusMesh(position){
            var outlineMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.BackSide, wireframe: true } );
            outlineMesh = new THREE.Mesh( RhombicDodecahedronGeometry, outlineMaterial );
            outlineMesh.position.set(position.x, position.y, position.z);
            outlineMesh.scale.multiplyScalar(1.05);
            scene.add( outlineMesh );
        }

        function removeOldFocusMesh(){
            scene.remove(outlineMesh);
        }

        function addParticleDebugInfo(object){
            var particle;
            particle = findParticleWithObjectId(object.id);
            // console.log(particle);
            if(particle.target.length !== 0){
                if(particle.target.length < 2){
                    document.querySelector('.debugParticle').innerHTML =
                        "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                        "Head Position : ("+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                        "Tail Position : ("+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                        "Role : " + particle.role + "<br>"+
                        "Target: ( " + particle.target[0].x + ", "+ particle.target[0].y +", "+ particle.target[0].z +" )<br>"
                    ;

                }else{
                    document.querySelector('.debugParticle').innerHTML =
                        "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                        "Head Position : ("+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                        "Tail Position : ("+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                        "Role : " + particle.role + "<br>"+
                        "Target 1: ( " + particle.target[0].x + ", "+ particle.target[0].y +", "+ particle.target[0].z +" )<br>"+
                        "Target 2: ( " + particle.target[1].x + ", "+ particle.target[1].y +", "+ particle.target[1].z +" )<br>"
                    ;
                }


            }else{
                document.querySelector('.debugParticle').innerHTML =
                    "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                    "Head Position : ("+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                    "Tail Position : ("+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                    "Role : " + particle.role + "<br>"+
                    "Target : []"
                ;
            }
        }

        var previousObject;
        var outlineMesh;
        function onDocumentMouseDown(event){
            if(true){
                // Get mouse position
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // Align raycaster with mouse and camera
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects( scene.children, true );
                if ( intersects.length > 0 ) {
                    if ( INTERSECTED != intersects[ 0 ].object ) {

                        if ( INTERSECTED ){
                            // console.log("first " + INTERSECTED);
                        }

                        INTERSECTED = intersects[ 0 ].object;
                        if(previousObject == null){
                            removeOldFocusMesh();
                            drawFocusMesh(INTERSECTED.parent.position);
                            addParticleDebugInfo(INTERSECTED.parent);

                        }else if((previousObject.parent.position.distanceTo(INTERSECTED.parent.position) !== 0)){

                            removeOldFocusMesh();
                            drawFocusMesh(INTERSECTED.parent.position);
                            previousObject = INTERSECTED;
                            addParticleDebugInfo(INTERSECTED.parent);
                        }else{
                            addParticleDebugInfo(INTERSECTED.parent);
                        }
                    }
                } else {
                    INTERSECTED = null;
                }
            }
        }

        function updateTargetMarker(particle){
            particle.target0.geometry.setFromPoints(getTargetMarkerPoints(particle.head.position, particle.target[0]));
            // particle.target1.computeLineDistances();
        }

        var particleSystemIdx = 0;
        var activations = 0;
        function nextSimulationStep(){
            if(randomParticleSelection){
                if(particleSystemIdx % (particleSystem.length) === 0){
                    shuffleArray(particleSystem);
                }
            }
            iterationStep(particleSystem[particleSystemIdx]);
            particleSystemIdx++;
            activations++;
            particleSystemIdx = particleSystemIdx % (particleSystem.length);

            document.querySelector('.simulationInfo').innerHTML = 'Number of activations: ' + activations + ' Round : '+ Math.ceil(activations/particleSystem.length);
        }


        function shuffleArray(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        function playSimulation(){
            console.log("Play Simulation");
            alternateButton[1].setEnabled();
            alternateButton[0].setDisabled();
            simulation = true;
        }

        function pauseSimulation(){
            console.log("Pause simulation");
            alternateButton[0].setEnabled();
            alternateButton[1].setDisabled();
            simulation = false;
        }


        var speed = 0.0;
        var createTree = false;
        var simulation = false;
        var debugMode = false;
        var stepDuration = 2000;
        var randomParticleSelection = false;

        var animate = function () {
            requestAnimationFrame( animate );
            if(simulation){
                // setTimeout(nextSimulationStep(), stepDuration);
                nextSimulationStep();
                // console.log(renderer.info.render.calls);

            }
            renderer.render( scene, camera );
        };

        animate();
    </script>

</body>
</html>