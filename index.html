<html>
<head>
    <title>3D Coating Algorithm</title>
    <style>
        html, body {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            margin: 0;
        }
        /*body { margin: 0; }*/
        canvas { display: block; }
        .no-pointer-events {
            pointer-events: none;
        }
        .control-disabled {
            color: #888;
            text-decoration: line-through;
        }
        #tooltip {
            position: fixed;
            left: 0;
            top: 0;
            min-width: 100px;
            min-height: 32px;
            text-align: center;
            padding: 5px 12px;
            font-family: monospace;
            color: white;
            background: rgba(0,0,0,0.5);
            display: none;
            opacity: 0;
            border: 1px solid black;
            box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
            transition: opacity 0.25s linear;
            border-radius: 3px;

            background-size: contain;
        }
        .simulationInfo {
            position: fixed;
            height: 40px;
            bottom:0;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugInfo {
            position: fixed;
            height: 40px;
            bottom:40px;
            width:100%;
            opacity: 1;
            z-index: 1;
            color: #fff;
            font-size: 30px;
            text-align: center;
            -webkit-text-stroke: 1px black;
        }
        .debugParticle {
            position: fixed;
            height: 240px;
            bottom: 0;
            left: 0;
            width: 180px;
            margin-left: 5px;
            margin-top: 5px;
            opacity: 1;
            z-index: 1;
            color: #000;
            font-size: 15px;
            text-align: left;
        }

    </style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/RhombicDodecahedronGeometry.js"></script>
<script src="js/Particle.js"></script>
<script src="js/ObjectParticle.js"></script>
<script src="js/Object.js"></script>
<script src="js/InitialParticles.js"></script>
<script src="js/stats.module.js"></script>
<div class="simulationInfo"></div>
<div class="debugInfo"></div>
<div class="debugParticle"></div>
    <script type="module">





        // SETUP
        import { GUI } from "./js/dat.gui.module.js";
        import Stats  from "./js/stats.module.js";
        import { TypedArrayUtils } from './js/TypedArrayUtils.js';

        // var kdtree = new TypedArrayUtils.Kdtree( particleSystem, distance, 3 );
        var controls;
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        var renderer = new THREE.WebGLRenderer( {antialias: true});
        var raycaster, mouse = { x: 0, y: 0 }, INTERSECTED;
        var singleLeader = false;
        var stats

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );


        // STATS
        stats = new Stats();
        document.body.appendChild( stats.dom );

        // RESPONSIVE PROJECT
        window.addEventListener( 'resize', function () {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize( width, height);
            camera.aspect = width/height;
            camera.updateProjectionMatrix();

        })




        // MOUSE CONTROL
        controls = new THREE.OrbitControls( camera, renderer.domElement );

        // initialize object to perform world/screen calculations
        raycaster = new THREE.Raycaster();

        // when the mouse moves, call the given function
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );

        function onDocumentMouseMove( event )
        {
            // the following line would stop any other event handler from firing
            // (such as the mouse's TrackballControls)
            // event.preventDefault();

            // update the mouse variable
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function distance(p1, p2){
            return Math.min(p1.head.position.distanceTo(p2.head.position),
                p1.head.position.distanceTo(p2.tail.position),
                p1.tail.position.distanceTo(p2.head.position),
                p1.tail.position.distanceTo(p2.tail.position),);
        }





        // ON-SCREEN PARAMETRERS (GUI)
        var gui = new GUI();
        var settings = {
            toggleGrid: false,
            toggleAxis: true,
            togglePointLightHelper: false,
            debugMode: false,
            // toggleSpotLightHelper: false,
            color: "#ffff00",
            wireFrame: false,
            extent: false,
            movement: false,
            objectcolor: "#00ff00",
            objectwireFrame: false,
            objectextent: false,
            role: "Inactive",
            initialParticlecolor: "#00ff00",
            initialParticlewireFrame: false,
            initialParticleextent: true,
            createTree: function(){ createTree = true },
            play: function(){ playSimulation() },
            pause: function(){ pauseSimulation() },
            rbyr: function(){ setSimulationRoundByRound()  },
            abya: function(){ setSimulationActivationByActivation() },
            speed: 10,
            nextStep: function(){ nextSimulationStep() },
            stopActivation: 0,
            random: false,
            x: 0,
            y: 0,
            z: 0,
            setMesh: function()
            {
                outlineMesh.position.set(meshPositionSetting.x, meshPositionSetting.y, meshPositionSetting.z);
            },

        };

        let debugGroup = gui.addFolder( 'Debug Tools' );
        debugGroup.add(settings, "toggleGrid").name( "Toggle Grid" ).onChange(function (visible) {
            gridHelper.visible = visible;
        })
        debugGroup.add(settings, "toggleAxis").name( "Toggle Axis" ).onChange(function (visible) {
            axesHelper.visible = visible;
        })
        debugGroup.add(settings, "togglePointLightHelper").name( "Point Light Helper" ).onChange(function (visible) {
            pointLightHelper[0].visible = visible;
            pointLightHelper[1].visible = visible;
            pointLightHelper[2].visible = visible;
            pointLightHelper[3].visible = visible;
            pointLightHelper[4].visible = visible;
        })
        debugGroup.add(settings, "debugMode").name( "Debug" ).onChange(function (value) {
            debugMode = value;
        })
        // debugGroup.add(settings, "toggleSpotLightHelper").name( "Spot Light Helper" ).onChange(function (visible) {
        //     spotLightHelper.visible = visible;
        // })
        // debugGroup.open();

        if(singleLeader){
            let particleGroup = gui.addFolder( 'Particle Settings' );
            particleGroup.addColor( settings, "color").name( "Color" ).onChange(function(value){
                coatingParticle.headRhombic.material.color.set(value);
            });
            particleGroup.add( settings, "wireFrame").name( "Wireframe" ).onChange(function(visible){
                coatingParticle.headRhombic.material.wireframe = visible;
            });
            particleGroup.add( settings, "extent").name( "Extent" ).onChange(function(visible){
                coatingParticle.headRhombic.visible = !visible;
                coatingParticle.headPoint.visible = visible;
                coatingParticle.tailRhombic.visible = !visible;
                coatingParticle.tailPoint.visible = visible;
            });
            particleGroup.add( settings, "movement").name( "Movement" ).onChange(function(value){
                if(value){
                    speed = 0.1;
                }else{
                    speed = 0;
                }

            });
            particleGroup.add( settings, 'role', [ "Inactive", "Retired", "Follower", "Coater", "Leader", "SmallLeader", "Branch", "SmallBranch", "Boundary"] ).name('Role').onChange(function(value){
                switch (value) {
                    case "Inactive":
                        coatingParticle.headRhombic.material.color.set(0x6C757D);
                        break;
                    case "Retired":
                        coatingParticle.headRhombic.material.color.set(0x121417);
                        break;
                    case "Follower":
                        coatingParticle.headRhombic.material.color.set(0x1D3557);
                        break;
                    case "Coater":
                        coatingParticle.headRhombic.material.color.set(0x1D3557);
                        break;
                    case "Leader":
                        coatingParticle.headRhombic.material.color.set(0xCF2626);
                        break;
                    case "SmallLeader":
                        coatingParticle.headRhombic.material.color.set(0xEA6C1B);
                        break;
                    case "Branch":
                        coatingParticle.headRhombic.material.color.set(0x583B23);
                        break;
                    case "SmallBranch":
                        coatingParticle.headRhombic.material.color.set(0x754E2F);
                        break;
                    case "Boundary":
                        coatingParticle.headRhombic.material.color.set(0x000000);
                        break;
                    default:
                        break

                }
            });
            particleGroup.open();
        }


        let objectGroup = gui.addFolder( 'Object Settings' );
        // objectGroup.addColor( settings, "objectcolor").name( "Color" ).onChange(function(value){
        //     for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
        //         layer[Object.keys(layer).length-1][i].head[0].material.color.set(value);
        //     }
        // });
        objectGroup.add( settings, "objectwireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(layer[Object.keys(layer).length-1]).length; i++) {
                layer[Object.keys(layer).length-1][i].head.material.wireframe = visible;
            }
        });
        objectGroup.add( settings, "objectextent").name( "Extent" ).onChange(function(visible){
            for (let j = 0; j < Object.keys(layer[Object.keys(layer).length-1]).length; j++) {
                layer[Object.keys(layer).length-1][j].headRhombic.visible = !visible;
                layer[Object.keys(layer).length-1][j].headPoint.visible = visible;
            }
        })
        objectGroup.open();

        let initialParticleGroup = gui.addFolder( 'Initial Particles Settings' );
        // initialParticleGroup.addColor( settings, "initialParticlecolor").name( "Color" ).onChange(function(value){
        //     for (let i = 0; i < Object.keys(initialParticles).length; i++) {
        //         initialParticles[i].head.material.color.set(value);
        //     }
        // });
        initialParticleGroup.add( settings, "initialParticlewireFrame").name( "Wireframe" ).onChange(function(visible){
            for (let i = 0; i < Object.keys(initialParticles).length; i++) {
                initialParticles[i].head.material.wireframe = visible;
            }
        });
        // initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
        //     for (let i = 0; i < Object.keys(initialParticles).length; i++) {
        //         initialParticles[i].headRhombic.visible = !visible;
        //         initialParticles[i].headPoint.visible = visible;
        //         initialParticles[i].tailRhombic.visible = !visible;
        //         initialParticles[i].tailPoint.visible = visible;
        //     }
        // });
        initialParticleGroup.add( settings, "initialParticleextent").name( "Extent" ).onChange(function(visible){
            for (let i = 0; i < particleSystem.length; i++) {
                particleSystem[i].headRhombic.visible = !visible;
                particleSystem[i].headPoint.visible = visible;
                particleSystem[i].tailRhombic.visible = !visible;
                particleSystem[i].tailPoint.visible = visible;
            }
        });
        initialParticleGroup.add( settings, "createTree").name( "Create Tree" );
        initialParticleGroup.open();

        let simulationGroup = gui.addFolder( 'Simulation Settings' );
        let alternateButton = [];
        alternateButton.push( simulationGroup.add( settings, 'play' ).name('&#9658 Play') );
        alternateButton.push( simulationGroup.add( settings, 'pause' ).name('&#10074&#10074 Pause') );
        let simulationStepGroup = simulationGroup.addFolder( 'Simulation Step Size' );
        alternateButton.push( simulationStepGroup.add( settings, 'rbyr' ).name('One Round') );
        alternateButton.push( simulationStepGroup.add( settings, 'abya' ).name('One Activation') );

        alternateButton.forEach( function ( control ) {

            control.classList1 = control.domElement.parentElement.parentElement.classList;
            control.classList2 = control.domElement.previousElementSibling.classList;

            control.setDisabled = function () {

                control.classList1.add( 'no-pointer-events' );
                control.classList2.add( 'control-disabled' );

            };

            control.setEnabled = function () {

                control.classList1.remove( 'no-pointer-events' );
                control.classList2.remove( 'control-disabled' );

            };
        })
        alternateButton[1].setDisabled();
        alternateButton[3].setDisabled();

        simulationGroup.add( settings, 'speed' ).min(0).max(100).step(1).name('Step Delay (ms)').onChange(function(value){
            stepDuration = value;
        });
        simulationGroup.add( settings, 'stopActivation' ).name('Stop At').onChange(function(value){
            stopAtActivation = value;
        });
        simulationGroup.add( settings, 'nextStep' ).name('Next Step &#x23ED');
        simulationGroup.add( settings, 'random' ).name('Randomization').onChange(function(value){
            randomParticleSelection = value;
        });


        simulationGroup.open();

        let highlightWireframeGroup = gui.addFolder( 'Highlight Wireframe Settings' );
        let positionGroup = highlightWireframeGroup.addFolder( 'Position' );
        var meshPositionSetting = new THREE.Vector3(0,0,0);
        positionGroup.add( settings, 'x' ).name('X').onChange(function(value){
            meshPositionSetting.setX(value);
        });
        positionGroup.add( settings, 'y' ).name('Y').onChange(function(value){
            meshPositionSetting.setY(value);
        });
        positionGroup.add( settings, 'z' ).name('Z').onChange(function(value){
            meshPositionSetting.setZ(value);
        });
        positionGroup.add( settings, "setMesh").name( "Set Mesh" );


        highlightWireframeGroup.open()





        // LIGHT
        var ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.1 );
        scene.add( ambientLight );

        var pointLight = {};
        pointLight[0] = new THREE.PointLight( 0xFFFFFF, 0.5 );
        pointLight[0].position.set( -20, 25, 25 );
        scene.add( pointLight[0] );

        pointLight[1] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[1].position.set( -25, -25, -25 );
        scene.add( pointLight[1] );

        pointLight[2] = new THREE.PointLight( 0xFFFFFF, 0.3 );
        pointLight[2].position.set( 33, 0, 0 );
        scene.add( pointLight[2] );

        pointLight[3] = new THREE.PointLight( 0xFFFFFF, 0.2 );
        pointLight[3].position.set( 0, -25, 25 );
        scene.add( pointLight[3] );

        pointLight[4] = new THREE.PointLight( 0xFFFFFF, 0.2 );
        pointLight[4].position.set( 0, 25, -25 );
        scene.add( pointLight[4] );


        // var spotLight = new THREE.SpotLight( 0xffffff, 0.6 );
        // spotLight.position.set( 5, 50, 5 );
        // scene.add( spotLight );

        // var spotLightHelper = new THREE.SpotLightHelper( spotLight, "#FF0000" );
        // spotLightHelper.visible = false;
        // scene.add( spotLightHelper );

        var sphereSize = 1;
        var pointLightHelper = {};
        pointLightHelper[0] = new THREE.PointLightHelper( pointLight[0], sphereSize, "#FF0000" );
        pointLightHelper[0].visible = false;
        scene.add( pointLightHelper[0] );

        pointLightHelper[1] = new THREE.PointLightHelper( pointLight[1], sphereSize, "#FF0000" );
        pointLightHelper[1].visible = false;
        scene.add( pointLightHelper[1] );

        pointLightHelper[2] = new THREE.PointLightHelper( pointLight[2], sphereSize, "#FF0000" );
        pointLightHelper[2].visible = false;
        scene.add( pointLightHelper[2] );

        pointLightHelper[3] = new THREE.PointLightHelper( pointLight[3], sphereSize, "#FF0000" );
        pointLightHelper[3].visible = false;
        scene.add( pointLightHelper[3] );

        pointLightHelper[4] = new THREE.PointLightHelper( pointLight[4], sphereSize, "#FF0000" );
        pointLightHelper[4].visible = false;
        scene.add( pointLightHelper[4] );


        // TEST




        // GRID
        var size = 1000;
        var divisions = 250;
        var gridHelper = new THREE.GridHelper( size, divisions );
        gridHelper.visible = false;
        // scene.add( gridHelper );



        // AXIS HELPER
        var axesHelper = new THREE.AxesHelper( 10 );
        axesHelper.material.linewidth = 5;
        scene.add( axesHelper );




        // OBJECT CREATION
        var availableMovementPositions = {};
        availableMovementPositions = generateObject(3, scene);

        // Multiple leader adjustments
        if(!singleLeader){
            moveInitialParticles();
        }


        // INITIAL PARTICLES CREATION
        renderInitialParticles(scene);





        // COATING PARTICLE
        if(singleLeader){
            var coatingParticle = new Particle();
            coatingParticle.head.position.set(availableMovementPositions[5].x, availableMovementPositions[5].y, availableMovementPositions[5].z);
            coatingParticle.tail.position.set(availableMovementPositions[5].x, availableMovementPositions[5].y, availableMovementPositions[5].z);
            coatingParticle.convertToRole("Leader");
            scene.add( coatingParticle.head );
            scene.add( coatingParticle.tail );
            scene.add( coatingParticle.headTailConnection );
            scene.add( coatingParticle.target0 );

        }

        // coatingParticle.headTailConnection.visible = false;






        camera.position.x = -50;
        camera.position.y = 25;
        camera.lookAt( 0, 0, 0 );
        scene.background = new THREE.Color( 0xffffff );

        function degrees_to_radians(degrees)
        {
            var pi = Math.PI;
            return degrees * (pi/180);
        }



        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function movementDebug(){
            console.log("  ");
            console.log(coatingParticle.headRhombic.position.x+ " and "+ targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x < targetPosition.x);
            console.log(coatingParticle.headRhombic.position.x > targetPosition.x);
            console.log(coatingParticle.headRhombic.position.y+ " and "+ targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y < targetPosition.y);
            console.log(coatingParticle.headRhombic.position.y > targetPosition.y);
            console.log(coatingParticle.headRhombic.position.z+ " and "+ targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z < targetPosition.z);
            console.log(coatingParticle.headRhombic.position.z > targetPosition.z);
        }

        function getNbrIdxAtPosition(position){
            for (let i = 0; i < particleSystem.length; i++) {
                if(position.distanceTo(particleSystem[i].head.position) === 0) {
                    return i;
                }
            }
            return -1;
        }

        function gatherParticles(){
            if(singleLeader){
                particleSystem.push(coatingParticle);
            }

            for (let i = 0; i < Object.keys(initialParticles).length ; i++) {
                particleSystem.push(initialParticles[i]);
                particleSystem[i].headRhombic.visible = false;
                particleSystem[i].headPoint.visible = true;
                particleSystem[i].tailRhombic.visible = false;
                particleSystem[i].tailPoint.visible = true;
            }
        }

        function doesPositionExistInParticleList(position){
            for (let i = 0; i < particleSystem.length; i++) {
                if(position.distanceTo(particleSystem[i].head.position) === 0) {
                    return true;
                }
                if(position.distanceTo(particleSystem[i].tail.position) === 0) {
                    return true;
                }
            }
            return false;
        }

        function doesPositionExistInList(position, list){
            for (let i = 0; i < list.length; i++) {
                if(position.distanceTo(list[i].head.position) === 0) {
                    return true;
                }
                if(position.distanceTo(list[i].tail.position) === 0) {
                    return true;
                }
            }
            return false;
        }

        function getAvExpandPosition(particle){
            var nbrPosition;
            var avPositions = [];
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                if(doesPositionExistInPositionList(nbrPosition, availableMovementPositions)){
                    if(!doesPositionExistInParticleList(nbrPosition)){
                        avPositions.push(nbrPosition);
                    }
                }
            }
            return avPositions;
        }


        function isParticleTargetingMyTail(particle, nbrParticle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(typeof nbrParticle.target[i] === "undefined"){
                    console.log("Tried to access target " + i)
                    console.log("Of particle:")
                    console.log(nbrParticle);
                }
                if(nbrParticle.target[i].distanceTo(particle.tail.position) === 0){
                    return true;
                }
            }
            return false;
        }

        function isParticleTargetingMyHead(particle, nbrParticle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(nbrParticle.target[i].distanceTo(particle.head.position) === 0){
                    return true;
                }

            }
            return false;
        }

        function isNbrOfRole(particle, role){
            var nbrPosition;
            for (let i = 0; i < 12; i++) {
                nbrPosition = particle.getPosAtFaceI(i);
                for (let j = 0; j < particleSystem.length; j++) {
                    if(nbrPosition.distanceTo(particleSystem[j].head.position) === 0){
                        if(particleSystem[j].role === role){
                            return true;
                        }
                    }
                }

            }
            return false;
        }

        function isTargetOfRole(particle, role){
            for (let j = 0; j < particleSystem.length; j++) {
                for (let i = 0; i < particle.target.length; i++) {
                    if(particle.target[i].distanceTo(particleSystem[j].head.position) === 0){
                        if(particleSystem[j].role === role){
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        // Branch helper functions

        function canCoaterBranch(coater){
            let targetIsCoater = false;
            let targetedByCoater = false;
            for (let j = 0; j < particleSystem.length; j++) {

                for (let i = 0; i < coater.target.length; i++) {
                    if(coater.target[i].distanceTo(particleSystem[j].tail.position) === 0){
                        if(particleSystem[j].role === "Coater"){
                            targetIsCoater = true;
                        }
                    }
                }



                for (let i = 0; i < particleSystem[j].target.length; i++) {
                    if( particleSystem[j].target[i] == null){
                        console.log(particleSystem[j]);
                    }
                    if(particleSystem[j].target[i].distanceTo(coater.tail.position) === 0){
                        if(particleSystem[j].role === "Coater"){
                            targetedByCoater = true;
                        }
                    }
                }

            }
            return (targetIsCoater && targetedByCoater);
        }

        function passSecondPointer(branch, smallBranch){
            smallBranch.target.push(findTargetFace(smallBranch, branch.target[0]))
        }


        function swapBranchTarget(branch){
            let tempTarget0 = branch.target[0];
            let tempTarget1 = branch.target[1];
            branch.target = [];
            branch.target.push(tempTarget1);
            branch.target.push(tempTarget0);
        }

        function updateBranchTargets(branch, pullingParticle){
            branch.target[0] = findTargetFace(branch, pullingParticle.tail.position);
            updateTargetMarker(branch);
            // branch.target0.geometry.setFromPoints(getTargetMarkerPoints(branch.head.position, branch.target[0]));
            // branch.target1.geometry.setFromPoints(getTargetMarkerPoints(branch.head.position, branch.target[1]));

        }

        function updateSmallBranchTargets(smallBranch, branch){
            smallBranch.target[0] = findTargetFace(smallBranch, branch.head.position);
            smallBranch.target.push(findTargetFace(smallBranch, branch.target[1]));
            updateTargetMarker(smallBranch);
            // smallBranch.target0.geometry.setFromPoints(getTargetMarkerPoints(smallBranch.head.position, branch.target[0]));
            // smallBranch.target1.geometry.setFromPoints(getTargetMarkerPoints(smallBranch.head.position, branch.target[1]));
        }

        function addBranchTargetVisualMarker(particle){
            // scene.add(particle.target1);
            if(particle.role === "Leaf"){
                particle.target1.geometry.setFromPoints(getTargetMarkerPoints(particle.tail.position, particle.target[0]));
            }else{
                particle.target0.geometry.setFromPoints(getTargetMarkerPoints(particle.tail.position, particle.target[1]));
            }
            updateTargetMarker(particle);
        }


        function getTargetMarkerPoints(origin, target){
            return [origin, findMidPoint(origin,target)];
        }

        function findMidPoint(vertex1, vertex2){
            return new THREE.Vector3((vertex1.x + vertex2.x) / 2, (vertex1.y + vertex2.y) / 2, (vertex1.z + vertex2.z) / 2);
        }



        function isTargetRetired(particle){
            for (let j = 0; j < particleSystem.length; j++) {
                for (let i = 0; i < particle.target.length; i++) {
                    if(particle.target[i].distanceTo(particleSystem[j].tail.position) === 0){
                        if(particleSystem[j].role === "Retired"){
                            particle.convertToRole("Coater");
                            let target;
                            if(i === 0){
                                target = particle.target[1];
                                particle.target = [];
                                particle.target.push(target);
                            }else{
                                target = particle.target[0];
                                particle.target = [];
                                particle.target.push(target);
                            }
                            return;
                        }
                    }
                }
            }
        }


        function contractParticle(particle){
            particle.tail.position.set(particle.head.position.x, particle.head.position.y, particle.head.position.z);
            particle.tail.visible = false;
            particle.headTailConnection.visible = false;
            particle.isContracted = true;
        }

        function isPullAbnormal(pullingParticle, pulledParticle){
            if(pullingParticle.tail.position.distanceTo(pulledParticle.head.position) > 4){
                console.log("Particle pulling :");
                console.log( pullingParticle );
                console.log("Particle being pulled :" );
                console.log( pulledParticle );
                pauseSimulation();
                return true;
            }
            return false;
        }

        var referenceCoordinate = new THREE.Vector3(0,0,0);
        function pullParticle(pullingParticle, pulledParticle){
            if(pulledParticle.role === "Retired"){
                console.log("Nani")   ;
                console.log(pulledParticle.role);
                return
            }
            if(isPullAbnormal(pullingParticle, pulledParticle)){
                return;
            }
            pulledParticle.tail.visible = true;
            pulledParticle.head.position.set(pullingParticle.tail.position.x, pullingParticle.tail.position.y, pullingParticle.tail.position.z);
            updateHeadTailMarker(pulledParticle);
            pulledParticle.headTailConnection.visible = true;
            pulledParticle.isContracted = false;
            if(pullingParticle.role === "Bridge" ||
                pullingParticle.role === "SmallBridge" ||
                pullingParticle.role === "Leader"||
                pullingParticle.role === "SmallLeader" ||
                pullingParticle.role === "SuperLeader" ||
                pullingParticle.role === "SmallSuperLeader"){
                leaderPointerHandover(pullingParticle, pulledParticle);
            }else{
                if(pulledParticle.role === "Bridge" ||
                    pulledParticle.role === "Leader"||
                    pulledParticle.role === "SuperLeader"){
                    inverseOldNewLeaderPointer(pulledParticle);
                }
            }


            contractParticle(pullingParticle);
            if(pullingParticle.role === "Branch"){
                updateSmallBranchTargets(pulledParticle, pullingParticle);
            }else if(pulledParticle.role === "Branch"){
                if(pulledParticle.target[1].distanceTo(pulledParticle.head.position) === 0){
                    swapBranchTarget(pulledParticle);
                }
                updateBranchTargets(pulledParticle, pullingParticle);
            }else{
                updateSingleTarget(pulledParticle, pullingParticle.tail.position);
                updateTargetMarker(pulledParticle);
            }
        }

        function alignFirstTargetConesToPoints(particle, position, target){
            particle.target0.position.setX((position.x + target.x) / 2);
            particle.target0.position.setY((position.y + target.y) / 2);
            particle.target0.position.setZ((position.z + target.z) / 2);
            particle.target0.lookAt(target);
        }

        function alignSecondTargetConesToPoints(particle, position, target){
            particle.target0.position.setX((position.x + target.x) / 2);
            particle.target0.position.setY((position.y + target.y) / 2);
            particle.target0.position.setZ((position.z + target.z) / 2);
            particle.target0.lookAt(target);
        }

        function updateHeadTailMarker(particle){
            alignCylinderToPoints(particle, particle.tail.position, particle.head.position);
        }

        function alignCylinderToPoints(particle, position, target){
            particle.headTailConnection.position.setX((position.x + target.x) / 2);
            particle.headTailConnection.position.setY((position.y + target.y) / 2);
            particle.headTailConnection.position.setZ((position.z + target.z) / 2);
            particle.headTailConnection.lookAt(target);
        }

        function findTargetFace(particle, target){
            let nbrFacePos;
            if(target.distanceTo(referenceCoordinate) === 0){
                return referenceCoordinate;
            }
            for (let i = 0; i < 12; i++) {
                nbrFacePos = particle.getPosAtFaceI(i);
                if(nbrFacePos.distanceTo(target) === 0){
                    return nbrFacePos;
                }
            }
            for (let i = 0; i < 12; i++) {
                nbrFacePos = particle.getPosAtFaceI(i, false);
                if(nbrFacePos.distanceTo(target) === 0){
                    return nbrFacePos;
                }
            }
            console.log("Error: Target is not a neighbour to particle");
            console.log("Error caused by particle:")
            console.log(particle);
            console.log("Attempted to assign Target:")
            console.log(target);
            pauseSimulation();
        }

        function isTargetNbrOfParticle(particle, target){
            for (let i = 0; i < 12; i++) {
                let nbrFacePos = particle.getPosAtFaceI(i);
                if(nbrFacePos.distanceTo(target) === 0){
                    return true;
                }
            }
            return false;
        }

        var interestPoint = new THREE.Vector3(-4,14, 10);
        function updateSingleTarget(particle, target){
            particle.target = [];
            particle.target.push(findTargetFace(particle, target));
        }

        function addTarget(particle, target){
            particle.target.push(findTargetFace(particle, target));
        }

        function checkIfFollowerCanContract(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(isParticleTargetingMyTail(particle, particleSystem[i])){
                    return false;
                }
            }
            return true;
        }

        function canLeaderRetire(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(particleSystem[i].isContracted){
                    if(particle.target.length > 0){
                        if(particle.target[0].distanceTo(particleSystem[i].head.position) === 0){
                            if(particleSystem[i].role === "Retired"){
                                return true;
                            }
                        }
                    }else{
                        return true;
                    }

                }
            }
            return false;
        }



        // ------------------------  ITERATION STEP   ------------------------ //

        var particleSystem = [];
        var expansionPhase = true;
        gatherParticles();
        setSuperLeader(false);

        function iterationStep(particle){
            if(particle.isContracted){

                switch (particle.role) {
                    case "Inactive":
                        var nbrPosition ;
                        for (let i = 0; i < 12; i++) {
                            nbrPosition = particle.getPosAtFaceI(i);
                            var nbrParticleIdx = getNbrIdxAtPosition(nbrPosition, particleSystem);
                            if(nbrParticleIdx > -1){
                                if(particleSystem[nbrParticleIdx].role === "Follower"){
                                    if(isHeadNbrObject(particle)){
                                        break;
                                    }else{
                                        updateSingleTarget(particle, nbrPosition);
                                        updateTargetMarker(particle);
                                        particle.convertToRole("Follower");
                                        break;
                                    }

                                }
                                else if(particleSystem[nbrParticleIdx].role === "Leader"){
                                    if(isHeadNbrObject(particle)){
                                        particle.convertToRole("Leader");
                                        initializeLeaderPointer(particle, particleSystem[nbrParticleIdx].tail.position);
                                        break;
                                    }else{
                                        if(particleSystem[nbrParticleIdx].tail.position.distanceTo(nbrPosition) === 0){
                                            updateSingleTarget(particle, nbrPosition);
                                            updateTargetMarker(particle);
                                            particle.convertToRole("Follower");
                                            break;
                                        }
                                    }
                                }else if(particleSystem[nbrParticleIdx].role === "SuperLeader"){
                                    if(isHeadNbrObject(particle)){
                                        particle.convertToRole("Leader");
                                        initializeLeaderPointer(particle, particleSystem[nbrParticleIdx].tail.position)
                                        break;
                                    }else{
                                        if(particleSystem[nbrParticleIdx].tail.position.distanceTo(nbrPosition) === 0){
                                            updateSingleTarget(particle, nbrPosition);
                                            updateTargetMarker(particle);
                                            particle.convertToRole("Follower");
                                            break;
                                        }
                                    }

                                }
                            }
                        }
                        break;
                    case "Bridge" :
                        if(!hasParentInT_L(particle)){
                            if(hasFollower(particle)){
                                // check if bridge is SuperLeader

                                if(isChildInT_SRetired(particle)){
                                    particle.target = [];
                                    particle.target.push(findTargetFace(particle, getNextLeader(particle)));
                                }

                                if (isBridgeReversed(particle)) {
                                    for (let i = 0; i < particleSystem.length; i++) {
                                        if (particle.target[0].distanceTo(particleSystem[i].head.position) === 0) {
                                            if (particleSystem[i].role === "Retired") {
                                                particle.convertToRole("Retired");
                                                particle.target = [];
                                                pauseSimulation();
                                                console.log("Layer COmpletererererer")
                                                break;
                                            }

                                        }
                                    }
                                }


                            }else{
                                particle.convertToRole("Retired");
                                particle.target = [];
                                break;
                            }
                        }else{
                            if (getNextLeader(particle).distanceTo(referenceCoordinate) === 0) {
                                if (canBridgeRetire(particle)) {
                                    particle.convertToRole("Retired");
                                    particle.target = [];
                                    break;
                                }
                            }

                            if (isBridgeReversed(particle)) {
                                for (let i = 0; i < particleSystem.length; i++) {
                                    if (particle.target[0].distanceTo(particleSystem[i].head.position) === 0) {
                                        if (particleSystem[i].role === "Retired") {
                                            particle.convertToRole("Retired");
                                            particle.target = [];
                                            break;
                                        }

                                    }
                                }
                            }

                            if(areAllParentBridgeReversed(particle)){
                                particle.target = [];
                                particle.target.push(findTargetFace(particle, getNextLeader(particle)));
                            }
                        }
                        break;
                    case "Leader":
                        if(particle.target.length === 0) {
                            if (isNbrOfRole(particle, "Inactive")) {
                                break;
                            }
                            let availablePositions = getAvExpandPosition(particle);
                            if (canExpand(availablePositions)) {
                                particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length - 1)]);
                                updateHeadTailMarker(particle);
                                break;
                            }
                            if(!hasFollower(particle)){
                                if(!hasParentInT_L(particle)){
                                    particle.convertToRole("Retired");
                                    particle.target = [];
                                    break;
                                }
                            }else{
                                if(!hasParentInT_L(particle)){
                                    particle.convertToRole("Bridge");
                                    particle.target.push(findTargetFace(particle, getNextLeader(particle)));
                                    break;
                                }
                            }
                        }
                        if(canLeaderRetire(particle)){ // child in T_S is retired
                            if(!hasFollower(particle)){
                                if(!hasParentInT_L(particle)){
                                    particle.convertToRole("Retired");
                                    particle.target = [];
                                    break;
                                }else{
                                    particle.convertToRole("Bridge");
                                    initializeBridge(particle);
                                    break;
                                }
                            }else{
                                if(!hasParentInT_L(particle)){
                                    // particle.convertToRole("Bridge");
                                    // particle.target = [];
                                    break;
                                }else{
                                    particle.convertToRole("Bridge");
                                    initializeBridge(particle);
                                }
                            }
                        }
                        break;
                    case "SuperLeader":
                        if(particle.target.length === 0) {
                            if (isNbrOfRole(particle, "Inactive")) {
                                break;
                            }
                            let availablePositions = getAvExpandPosition(particle);
                            if (canExpand(availablePositions)) {
                                particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length - 1)]);
                                updateHeadTailMarker(particle);
                                break;
                            }
                        }
                        if(canLeaderRetire(particle)){ // child in T_S is retired
                            if(!hasFollower(particle)){
                                if(!hasParentInT_L(particle)){
                                    particle.convertToRole("Retired");
                                    particle.target = [];
                                    break;
                                }else{
                                    particle.convertToRole("Bridge");
                                    initializeBridge(particle);
                                }
                            }else{
                                particle.convertToRole("Bridge");
                                initializeBridge(particle);
                                break;
                            }
                        }
                        break;
                    case "Leaf":
                        // Check if a nbr is Follower
                        let availablePositions = getAvExpandPosition(particle);
                        if(availablePositions.length > 0){
                            particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length-1)]);
                            updateHeadTailMarker(particle);
                        }else{
                            particle.convertToRole("Retired");
                            particle.target = [];
                            scene.remove(particle.tail);
                            scene.remove(particle.target0);
                            scene.remove(particle.target1);
                            break;
                        }
                        break;
                    case "Coater":
                        if(isTargetOfRole(particle, "Retired")){
                            particle.convertToRole("Leaf");
                            scene.remove(particle.target0);
                            break;
                        }
                        if(canCoaterBranch(particle)){
                            let availablePositions = getAvExpandPosition(particle);
                            let target = particle.target;
                            if(availablePositions.length > 0) {
                                particle.expandParticle(availablePositions[getRandomInt(0, availablePositions.length - 1)]);
                                particle.convertToRole("Leaf");
                                particle.target = target;
                                updateTargetMarker(particle);
                                // addBranchTargetVisualMarker(particle);
                            }
                        }
                        break;
                    case "Branch":
                        isTargetRetired(particle);
                        break;
                    case "Follower":
                        if(isTargetOfRole(particle, "Retired")){
                            if(nextLayerReady){
                                particle.convertToRole("Leader");
                                particle.target = [];
                                pauseSimulation();
                            }
                        }
                        break;
                }


            }else{
                switch (particle.role) {
                    case "Leader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallLeader");
                                if(particle.target.length === 0){
                                    particle.convertToRole("Leaf");
                                }else{
                                    particle.convertToRole("Coater");
                                }
                                particle.leaderPointer = referenceCoordinate;
                                particle.oldLeaderPointer = referenceCoordinate;
                                break;
                            }
                        }
                        break;
                    case "SmallLeader":
                        if(!hasFollower(particle)){
                            if(!isTailNbrObject(particle)){
                                contractParticle(particle);
                                particle.convertToRole("Leader");
                                break;
                            }
                        }
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                if(isTailNbrObject(particle)){
                                    if(getNextLeader(particleSystem[j]).distanceTo(particle.tail.position) === 0){
                                        pullParticle(particle, particleSystem[j]);
                                        particle.convertToRole("Leader");
                                    }else{
                                        pullParticle(particle, particleSystem[j]);
                                        particle.convertToRole("Leader");
                                        if(particleSystem[j].role !== "Bridge"){
                                            particleSystem[j].convertToRole("SmallBridge");
                                        }
                                    }
                                }else{
                                    pullParticle(particle, particleSystem[j]);
                                    particle.convertToRole("Leader");
                                }
                                break;
                            }
                        }
                        break;
                    case "SuperLeader":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallSuperLeader");
                                if(particle.target.length === 0){
                                    particle.convertToRole("Leaf");
                                }else{
                                    particle.convertToRole("Coater");
                                }
                                particle.leaderPointer = referenceCoordinate;
                                particle.oldLeaderPointer = referenceCoordinate;                                break;
                            }
                        }
                        break;
                    case "SmallSuperLeader":
                        if(!hasFollower(particle)){
                            if(!isTailNbrObject(particle)){
                                contractParticle(particle);
                                particle.convertToRole("SuperLeader");
                                break;
                            }
                        }
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                if(isTailNbrObject(particle)){
                                    if(getNextLeader(particleSystem[j]).distanceTo(particle.tail.position) === 0){
                                        pullParticle(particle, particleSystem[j]);
                                        particle.convertToRole("SuperLeader");
                                    }else{
                                        pullParticle(particle, particleSystem[j]);
                                        particle.convertToRole("SuperLeader");
                                        if(particleSystem[j].role !== "Bridge"){
                                            particleSystem[j].convertToRole("SmallBridge");
                                        }
                                    }
                                }else{
                                    pullParticle(particle, particleSystem[j]);
                                    particle.convertToRole("SuperLeader");
                                }
                                break;
                            }
                        }
                        break;
                    case "Bridge" :
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                if(!isTailNbrObject(particleSystem[j])){
                                    pullParticle(particle, particleSystem[j]);
                                    particleSystem[j].convertToRole("SmallBridge");
                                    updateBridgeTargets(particle);
                                }else{
                                    pullParticle(particle, particleSystem[j]);
                                    updateBridgeTargets(particle);
                                }
                                break;
                            }
                        }
                        break;
                    case "SmallBridge":
                        if(!hasFollower(particle)){
                            if(!isTailNbrObject(particle)){
                                contractParticle(particle);
                                particle.convertToRole("Bridge");
                                break;
                            }
                        }
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particle.convertToRole("Bridge");
                                initializeBridge(particle);
                                break;
                            }
                        }
                        break;
                    case "Branch":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particleSystem[j].convertToRole("SmallBranch");
                                particle.convertToRole("Coater");
                                particle.target.pop();
                                particle.target1.visible = false;
                                break;
                            }
                        }
                        break;
                    case "SmallBranch":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                particle.convertToRole("Branch");
                                break;
                            }
                        }
                        break;
                    case "Follower":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        if(!hasFollower(particle)){
                            contractParticle(particle);
                        }
                        break;
                    case "Coater":
                        for (let j = 0; j < particleSystem.length; j++) {
                            if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                pullParticle(particle, particleSystem[j]);
                                break;
                            }
                        }
                        break;
                    case "Leaf":
                        if(particle.target.length > 0){
                            for (let j = 0; j < particleSystem.length; j++) {
                                if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                    pullParticle(particle, particleSystem[j]);
                                    particleSystem[j].convertToRole("SmallBranch");
                                    passSecondPointer(particle, particleSystem[j]);
                                    particle.target = [];
                                    break;
                                }
                            }
                        }else{
                            for (let j = 0; j < particleSystem.length; j++) {
                                if(isParticleTargetingMyTail(particle, particleSystem[j]) && particleSystem[j].isContracted){
                                    pullParticle(particle, particleSystem[j]);
                                    break;
                                }
                            }
                        }
                        break;
                }
            }

        }

        // ------------------------  ITERATION STEP END   ------------------------ //

        function canExpand(availablePositions){
            return availablePositions.length > 0;
        }



        // Retraction phase
        function isAParticleTargetingMe(particle){
            for (let i = 0; i < particleSystem.length ; i++) {
                if(isParticleTargetingMyHead(particle, particleSystem[i]) || isParticleTargetingMyTail(particle, particleSystem[i])){
                    return true;
                }
            }
            return false
        }

        function reversePullParticle(pullingParticle, pulledParticle){
            if(pullingParticle.head.position.distanceTo(pulledParticle.tail.position) > 4){
                console.log("Dangerous Reverse Pull")
                console.log("Particle pulling :");
                console.log( pullingParticle );
                console.log("Particle being pulled :" );
                console.log( pulledParticle );
                pauseSimulation();
                return;
            }

            pulledParticle.tail.visible = true;
            pulledParticle.tail.position.set(pullingParticle.head.position.x, pullingParticle.head.position.y, pullingParticle.head.position.z);
            // pulledParticle.headTailConnection.geometry.setFromPoints([pulledParticle.head.position, pulledParticle.tail.position]);
            alignCylinderToPoints(pulledParticle, pulledParticle.tail.position, pulledParticle.head.position)
            pulledParticle.headTailConnection.visible = true;
            pulledParticle.isContracted = false;
            reverseContractParticle(pullingParticle);
            if(pullingParticle.role === "Branch"){
                updateSmallBranchTargets(pulledParticle, pullingParticle);
            }else if(pulledParticle.role === "Branch"){
                if(pulledParticle.target[1].distanceTo(pulledParticle.head.position) === 0){
                    swapBranchTarget(pulledParticle);
                }
                updateBranchTargets(pulledParticle, pullingParticle);
            }else{
                updateSingleTarget(pulledParticle, pullingParticle.tail.position);
                updateTargetMarker(pulledParticle);
            }
        }

        function reverseContractParticle(particle){
            particle.head.position.set(particle.tail.position.x, particle.tail.position.y, particle.tail.position.z);
            particle.tail.visible = false;
            particle.headTailConnection.visible = false;
            particle.isContracted = true;
        }

        // Trigger Next Layer
        var layerSystem = [];
        function retireLayer(){
            let newParticleSystem = [];
            for (let i = 0; i < particleSystem.length; i++) {
                if(particleSystem[i].role === "Retired"){
                    layerSystem.push(particleSystem[i]);
                }else{
                    newParticleSystem.push(particleSystem[i]);
                }
            }
            particleSystem = [];
            for (let i = 0; i < newParticleSystem.length; i++) {
                console.log("particle added");
                particleSystem.push(newParticleSystem[i]);
            }
        }


        function findNewAvPositions(){
            let layerIdx = Object.keys(layer).length-1;
            let avPosition = {};
            let arrayIdx = 0;
            // For each particle in Layer[layerIdx]
            for (let j = 0; j < layerSystem.length; j++) {
                for (let i = 0; i < 12; i++) {
                    // Get position adjacent to face j
                    let particleNbrPosition = layerSystem[j].getPosAtFaceI(i);
                    if(!doesPositionExistInLayer(particleNbrPosition, layer[layerIdx])){
                        if(!doesPositionExistInList(particleNbrPosition, layerSystem)){
                            if(!doesPositionExistInPositionList(particleNbrPosition, avPosition)) {
                                avPosition[arrayIdx] = new THREE.Vector3(particleNbrPosition.x, particleNbrPosition.y, particleNbrPosition.z)
                                arrayIdx++;
                            }
                        }
                    }
                }
            }
            return avPosition;
        }



        // 3D Coordinate System Improvement

        var coordinateSystem = new Array(new Array([]));
        var negativeCoordinateOffset = 25;
        var useImprovedMethod = true;

        function findParticleInCoordSys(coordinate){
            if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] != null){
                return coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset];
            }
        }

        function addParticleToCoordSys(particle, coordinate){
            if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] != null){
                coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
            }else{
                console.log("Can't add particle to system, coordinate is already occupied");
            }
        }

        function contractParticleInCoordSys(particle){
            if(coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] != null){
                if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset]){
                    coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
                    coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] = particle;
                }else{
                    console.log("Cannot update target coordinate, target coordinate is already occupied");
                }
            }else{
                console.log("Particle not found in the coordinate system");
            }
        }

        function expandParticleInCoordSys(particle, target){
            if(coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] != null){
                if(coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset]){
                    coordinateSystem[coordinate.x + negativeCoordinateOffset][coordinate.y + negativeCoordinateOffset][coordinate.z + negativeCoordinateOffset] = particle;
                    coordinateSystem[particle.x + negativeCoordinateOffset][particle.y + negativeCoordinateOffset][particle.z + negativeCoordinateOffset] = particle;
                }else{
                    console.log("Cannot update target coordinate, target coordinate is already occupied");
                }
            }else{
                console.log("Particle not found in the coordinate system");
            }
        }


        // MULTIPLE LEADER FUNCTIONS


        function setSuperLeader(random) {
            if(random){

            }else{
                particleSystem[0].convertToRole("SuperLeader");
                console.log(particleSystem.length);
                // var superLeaderPosition = new THREE.Vector3(-4, 6, 2);
                // for (let i = 0; i < particleSystem.length; i++) {
                //     if(particleSystem[i].head.position.distanceTo(superLeaderPosition) === 0){
                //         particleSystem[i].convertToRole("SuperLeader")
                //     }
                // }
            }
        }


        // Check if particle.head is neighbour to Object O (is the head of the particle in contact with object)
        function isHeadNbrObject(particle){
            for (let i = 0; i < objectParticleList.length; i++) {
                for (let j = 0; j < 12; j++) {
                    let positionNbrParticle = particle.getPosAtFaceI(j);
                    if(objectParticleList[i].head.position.distanceTo(positionNbrParticle) === 0){
                        return true;
                    }
                }
            }
            return false;
        }

        // Check if particle.tail is neighbour to Object O (is the tail of the particle in contact with object)
        function isTailNbrObject(particle){
            for (let i = 0; i < Object.keys(availableMovementPositions).length; i++) {
                if(particle.tail.position.distanceTo(availableMovementPositions[i]) === 0){
                    return true;
                }
            }
            return false;
        }

        function isChildInT_SRetired(particle){
            for (let i = 0; i < particleSystem.length; i++) {
                if(particle.target.length > 0) {
                    for (let j = 0; j < particle.target.length; j++) {
                        if(particle.target[j].distanceTo(particleSystem[i].head.position) === 0){
                            if(particleSystem[i].role === "Retired"){
                                return true;
                            }
                        }
                    }
                }else{
                    console.log("problem in isChildInT_SRetired")
                }
            }
            return false;
        }

        function initializeLeaderPointer(particle, pointerPosition){
            particle.leaderPointer = findTargetFace(particle, pointerPosition);
            particle.oldLeaderPointer = findTargetFace(particle, pointerPosition);
        }

        function initializeBridge(particle){
            if(!particle.isContracted){
                console.log("problem");
            }
            if(isBridgeReversed(particle)){
                return;
            }else{
                particle.target = [];
            }


            for (let i = 0; i < particleSystem.length; i++) {
                if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0){
                    if(particleSystem[i].role === "Leader" || particleSystem[i].role === "Bridge" ||
                        particleSystem[i].role === "Follower" || particleSystem[i].role === "SmallLeader" ||
                        particleSystem[i].role === "SmallSuperLeader"){
                        if(isBridgeReversed(particleSystem[i])){
                            continue;
                        }
                        if(isPosAdjacent(particle, particleSystem[i].tail.position)){
                            addTarget(particle, particleSystem[i].tail.position);
                        }else{
                            addTarget(particle, particleSystem[i].head.position);
                        }
                    }
                }
            }
        }

        function isPosAdjacent(particle, pos){
            for (let i = 0; i < 12; i++) {
                let positionNbrParticle = particle.getPosAtFaceI(i);
                if(positionNbrParticle.distanceTo(pos) === 0){
                    return true;
                }
            }
            for (let i = 0; i < 12; i++) {
                let positionNbrParticle = particle.getPosAtFaceI(i, false);
                if(positionNbrParticle.distanceTo(pos) === 0){
                    return true;
                }
            }
            return false;
        }

        function updateBridgeTargets(particle){
            for (let i = 0; i < particleSystem.length; i++) {
                if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0){
                    if(particleSystem[i].role === "Leader" || particleSystem[i].role === "Bridge" ||
                        particleSystem[i].role === "Follower" || particleSystem[i].role === "SmallLeader" ||
                        particleSystem[i].role === "SmallSuperLeader" || particleSystem[i].role === "Retired"){
                        if(isPosAdjacent(particle, particleSystem[i].tail.position)){
                            addTarget(particle, particleSystem[i].tail.position);
                        }else{
                            addTarget(particle, particleSystem[i].head.position);
                        }
                    }
                }
            }
        }

        function getNextLeader(particle){
            if(particle.leaderPointer.distanceTo(particle.head.position) === 0 ||
                particle.leaderPointer.distanceTo(particle.tail.position) === 0){
                return particle.oldLeaderPointer;
            }else{
                return particle.leaderPointer;
            }
        }

        function checkIfTargetExists(particle, target){
            for (let i = 0; i < particle.target.length; i++) {
                if(particle.target[i].distanceTo(target) === 0){
                    return true
                }
            }
            return false;
        }

        function hasParentInT_L(particle){
            for (let i = 0; i < particleSystem.length; i++) {
                if(particleSystem[i].role === "Leader" ||
                    particleSystem[i].role === "SmallLeader" ||
                    particleSystem[i].role === "SuperLeader" ||
                    particleSystem[i].role === "SmallSuperLeader" ||
                    particleSystem[i].role === "Bridge" ||
                    particleSystem[i].role === "SmallBridge"
                ){
                    if (getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0 ||
                        getNextLeader(particleSystem[i]).distanceTo(particle.tail.position) === 0) {
                        return true;
                    }
                }

            }
            return false;
        }

        function areAllParentBridgeReversed(particle){
            let aParentBridgeIsReversed = false;
            for (let i = 0; i < particleSystem.length; i++) {
                if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0) {
                    if(particleSystem[i].role === "Bridge"){
                        if(isBridgeReversed(particleSystem[i])){
                            aParentBridgeIsReversed = true;
                        }else{
                            return false;
                        }
                    }
                }
            }
            return aParentBridgeIsReversed;
        }

        function isBridgeReversed(particle){
            for (let i = 0; i < particle.target.length; i++) {
                if(getNextLeader(particle).distanceTo(particle.target[i]) === 0){
                    return true;
                }
            }
            return false;
        }

        function canBridgeRetire(particle){
            // there must at least be one retired particle targeting "particle"
            // TODO: if only one leader exists will not work
            // let numberRetiredParticles = 0;
            // for (let i = 0; i < particleSystem.length; i++) {
            //     if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0){
            //         if(particleSystem[i].role === "Retired"){
            //             numberRetiredParticles++;
            //         }else{
            //             return false;
            //         }
            //     }
            // }
            // if(numberRetiredParticles > 0){
            //     return true;
            // }
            // return false;
            for (let i = 0; i < particleSystem.length ; i++) {
                if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0){
                    if(isBridgeReversed(particleSystem[i]) ||
                        particleSystem[i].role === "Retired"){
                        console.log("gucci");
                    }else{
                        return false
                    }
                }
            }
            // for (let i = 0; i < particleSystem.length ; i++) {
            //     if(getNextLeader(particleSystem[i]).distanceTo(particle.head.position) === 0){
            //         if(isBridgeReversed(particleSystem[i]) ){
            //             console.log("gucci");
            //         }else{
            //             return false
            //         }
            //     }
            // }
            return true;

        }

        function hasFollower(particle){
            for (let i = 0; i < particleSystem.length; i++) {
                for (let j = 0; j < particleSystem[i].target.length; j++) {
                    if(doesTargetMatchTail(particleSystem[i].target[j], particle)){
                        if(particleSystem[i].role === "Follower"){
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        var nextLayerReady = false;
        function prepareNextLayer(){
            retireLayer();
            availableMovementPositions = findNewAvPositions();
            nextLayerReady = true;

        }

        function doesTargetMatchParticle(target, particle){
            return doesTargetMatchTail(target, particle) || doesTargetMatchHead(target, particle);
        }

        function doesTargetMatchTail(target, particle){
            return (particle.tail.position.distanceTo(target) === 0);
        }

        function doesTargetMatchHead(target, particle){
            return (particle.head.position.distanceTo(target) === 0);
        }

        function doesParticleTargetsMatchParticle(nbrParticle, particle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(doesTargetMatchTail(nbrParticle.target[i], particle) || doesTargetMatchHead(nbrParticle.target[i], particle)){
                    return true;
                }
            }
            return false;
        }

        function doesParticleTargetsMatchTail(nbrParticle, particle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(particle.tail.position.distanceTo(nbrParticle.target[i]) === 0){
                    return true;
                }
            }
            return false;
        }

        function doesParticleTargetsMatchHead(nbrParticle, particle){
            for (let i = 0; i < nbrParticle.target.length; i++) {
                if(particle.head.position.distanceTo(nbrParticle.target[i]) === 0){
                    return true;
                }
            }
            return false;
        }



        function leaderPointerHandover(pullingParticle, pulledParticle){
            pulledParticle.oldLeaderPointer = findTargetFace(pulledParticle, pulledParticle.leaderPointer);
            pulledParticle.leaderPointer = findTargetFace(pulledParticle, pullingParticle.oldLeaderPointer);
            if(!isTailNbrObject(pullingParticle)){
                pulledParticle.oldLeaderPointer = findTargetFace(pulledParticle, pullingParticle.oldLeaderPointer);
            }
        }

        function inverseOldNewLeaderPointer(particle){
            particle.oldLeaderPointer = findTargetFace(particle, particle.leaderPointer);
        }

        // DEBUG FUNCTIONS
        function update()
        {
            document.querySelector('.simulationInfo').innerHTML = 'Number of renders: ' + renderer.info.render.calls;

            // controls.update();
            // stats.update();
        }

        function findParticleWithObjectId(objectID){
            for (let i = 0; i < particleSystem.length; i++) {
                if((particleSystem[i].head.id === objectID) || (particleSystem[i].tail.id === objectID)){
                    return particleSystem[i];
                }
            }
        }

        function findObjectParticleWithObjectId(objectID){
            for (let i = 0; i < objectParticleList.length; i++) {
                if((objectParticleList[i].head.id === objectID)){
                    return objectParticleList[i];
                }
            }
        }

        function drawFocusMesh(position){
            var outlineMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.BackSide, wireframe: true } );
            outlineMesh = new THREE.Mesh( RhombicDodecahedronGeometry, outlineMaterial );
            outlineMesh.position.set(position.x, position.y, position.z);
            outlineMesh.scale.multiplyScalar(1.05);
            scene.add( outlineMesh );
        }

        function removeOldFocusMesh(){
            scene.remove(outlineMesh);
        }

        function addParticleDebugInfo(object){
            let particle = findParticleWithObjectId(object.id);
            let particleObject = findObjectParticleWithObjectId(object.id);
            // console.log(particle);
            if(typeof particle === 'undefined' && typeof particleObject !== 'undefined'){
                document.querySelector('.debugParticle').innerHTML =
                    "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"
            }else if(typeof particle !== 'undefined' && typeof particleObject === 'undefined'){
                if(particle.target.length !== 0){
                    if(particle.target.length < 2){
                        document.querySelector('.debugParticle').innerHTML =
                            "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                            "Head Position : ( "+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                            "Tail Position : ( "+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                            "Role : " + particle.role + "<br>"+
                            "Target: ( " + particle.target[0].x + ", "+ particle.target[0].y +", "+ particle.target[0].z +" )<br>"+
                            "Next Leader: ( "+ + particle.leaderPointer.x + ", "+ particle.leaderPointer.y +", "+ particle.leaderPointer.z +" )<br>"+
                            "Old Leader: ( "+ + particle.oldLeaderPointer.x + ", "+ particle.oldLeaderPointer.y +", "+ particle.oldLeaderPointer.z +" )"
                        ;

                    }else{
                        document.querySelector('.debugParticle').innerHTML =
                            "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                            "Head Position : ( "+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                            "Tail Position : ( "+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                            "Role : " + particle.role + "<br>"+
                            "Target 1: ( " + particle.target[0].x + ", "+ particle.target[0].y +", "+ particle.target[0].z +" )<br>"+
                            "Target 2: ( " + particle.target[1].x + ", "+ particle.target[1].y +", "+ particle.target[1].z +" )<br>"+
                            "Next Leader: ( "+ + particle.leaderPointer.x + ", "+ particle.leaderPointer.y +", "+ particle.leaderPointer.z +" )<br>"+
                            "Old Leader: ( "+ + particle.oldLeaderPointer.x + ", "+ particle.oldLeaderPointer.y +", "+ particle.oldLeaderPointer.z +" )"
                        ;
                    }


                }else{
                    document.querySelector('.debugParticle').innerHTML =
                        "Position: ( " + outlineMesh.position.x + ", "+ outlineMesh.position.y +", "+ outlineMesh.position.z +" )<br>"+
                        "Head Position : ( "+ particle.head.position.x + ", "+ particle.head.position.y +", "+ particle.head.position.z +" )<br>"+
                        "Tail Position : ( "+ particle.tail.position.x + ", "+ particle.tail.position.y +", "+ particle.tail.position.z +" )<br>"+
                        "Role : " + particle.role + "<br>"+
                        "Target : []"+"<br>"+
                        "Next Leader: ( "+ + particle.leaderPointer.x + ", "+ particle.leaderPointer.y +", "+ particle.leaderPointer.z +" )<br>"+
                        "Old Leader: ( "+ + particle.oldLeaderPointer.x + ", "+ particle.oldLeaderPointer.y +", "+ particle.oldLeaderPointer.z +" )"
                    ;
                }
            }

        }

        var previousObject;
        var outlineMesh;
        function onDocumentMouseDown(event){
            if(true){
                // Get mouse position
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // Align raycaster with mouse and camera
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObjects( scene.children, true );
                if ( intersects.length > 0 ) {
                    if ( INTERSECTED != intersects[ 0 ].object ) {
                        if ( INTERSECTED ){
                            // console.log("first " + INTERSECTED);
                        }
                        INTERSECTED = intersects[ 0 ].object;
                        if(previousObject == null){
                            removeOldFocusMesh();
                            drawFocusMesh(INTERSECTED.parent.position);
                            addParticleDebugInfo(INTERSECTED.parent);

                        }else if((previousObject.parent.position.distanceTo(INTERSECTED.parent.position) !== 0)){

                            removeOldFocusMesh();
                            drawFocusMesh(INTERSECTED.parent.position);
                            previousObject = INTERSECTED;
                            addParticleDebugInfo(INTERSECTED.parent);
                        }else{
                            addParticleDebugInfo(INTERSECTED.parent);
                        }
                    }
                } else {
                    INTERSECTED = null;
                }
            }
        }

        function updateTargetMarker(particle){
            let firstTarget;
            let secondTarget;
            if(particle.target.length > 1){
                particle.target0.visible = true;
                particle.target1.visible = true;
                firstTarget = getTargetMarkerPoints(particle.head.position, particle.target[0]);
                secondTarget = getTargetMarkerPoints(particle.head.position, particle.target[1]);
                alignFirstTargetConesToPoints(particle, firstTarget[0], firstTarget[1]);
                alignSecondTargetConesToPoints(particle, secondTarget[0], secondTarget[1]);
            }else if (particle.target.length > 0){
                particle.target0.visible = true;
                particle.target1.visible = false;
                firstTarget = getTargetMarkerPoints(particle.head.position, particle.target[0]);
                alignFirstTargetConesToPoints(particle, firstTarget[0], firstTarget[1]);
            }else{
                particle.target0.visible = false;
                particle.target1.visible = false;
            }

            // particle.target1.computeLineDistances();
        }

        function updateBranchMarkerSpecial(particle){
            for (let i = 0; i < particle.target.length; i++) {
                for (let j = 0; j < 12; j++) {
                    let positionNbrParticle = particle.getPosAtFaceI(j);
                    if(positionNbrParticle.distanceTo(particle.target[i]) === 0){
                        if(i === 0){
                            let firstTarget = getTargetMarkerPoints(particle.head.position, particle.target[0]);
                            alignFirstTargetConesToPoints(particle, firstTarget[0], firstTarget[1]);
                        }else if (i === 1){
                            let secondTarget = getTargetMarkerPoints(particle.head.position, particle.target[1]);
                            alignFirstTargetConesToPoints(particle, secondTarget[0], secondTarget[1]);
                        }
                    }
                }
            }
        }

        var particleSystemIdx = 0;
        var activations = 0;
        function nextSimulationStep(){
            if(stopAtActivation > 0){
               if(stopAtActivation === activations){
                   pauseSimulation();
               }
            }
            if(randomParticleSelection){
                if(particleSystemIdx % (particleSystem.length) === 0){
                    shuffleArray(particleSystem);
                }
            }
            if(simulationRoundByRound){
                for (let i = 0; i < particleSystem.length; i++) {
                    iterationStep(particleSystem[particleSystemIdx]);
                    particleSystemIdx++;
                    activations++;
                    particleSystemIdx = particleSystemIdx % (particleSystem.length);
                }
            }else{
                iterationStep(particleSystem[particleSystemIdx]);
                particleSystemIdx++;
                activations++;
                particleSystemIdx = particleSystemIdx % (particleSystem.length);
            }


            document.querySelector('.simulationInfo').innerHTML = 'Number of activations: ' + activations + ' Round : '+ Math.ceil(activations/particleSystem.length);
        }


        function shuffleArray(array) {
            for (var i = array.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        function setSimulationRoundByRound(){
            alternateButton[3].setEnabled();
            alternateButton[2].setDisabled();
            simulationRoundByRound = true;

        }

        function setSimulationActivationByActivation(){
            alternateButton[2].setEnabled();
            alternateButton[3].setDisabled();
            simulationRoundByRound = false;
        }

        function playSimulation(){
            console.log("Play Simulation");
            alternateButton[1].setEnabled();
            alternateButton[0].setDisabled();
            simulation = true;
        }

        function pauseSimulation(){
            console.log("Pause simulation");
            alternateButton[0].setEnabled();
            alternateButton[1].setDisabled();
            simulation = false;
        }

        // function startSimulation(){
        //     while(true){
        //         nextSimulationStep();
        //     }
        // }


        var speed = 0.0;
        var createTree = false;
        var simulation = false;
        var debugMode = false;
        var stepDuration = 2000;
        let stopAtActivation = 0;
        var randomParticleSelection = false;
        var simulationRoundByRound = false;


        var animate = function () {
            requestAnimationFrame( animate );
            if(simulation){

                // console.time('someFunction')

                // console.timeEnd('someFunction')

                // console.time('someOtherFunction')
                nextSimulationStep();
                // for (let j = 0; j < 10; j++) {
                //     let randomInt = getRandomInt(0,particleSystem.length-1);
                //     let adjacentParticles = kdtree.nearest(particleSystem[randomInt], 4);
                //     for (let i = 0; i < adjacentParticles.length; i++) {
                //         if(adjacentParticles[i].head.position.distanceTo(particleSystem[i].head.position)){
                //             break;
                //         }
                //     }
                // }
                // console.timeEnd('someOtherFunction')


                // console.log(renderer.info.render.calls);

            }
            stats.update();
            renderer.render( scene, camera );
        };


        animate();
    </script>

</body>
</html>